<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Scroll of Seven Seals - FIXED WINNER v1.3.1</title>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    
    <!-- Enhanced Challenge System - Load BEFORE main game script -->
    <script src="js/game-data.js"></script>
    <script src="js/dynamic-engine.js"></script>
    <script src="js/immersion-engine.js"></script>
    <script src="js/puzzles.js"></script>

    <link rel="stylesheet" href="enhanced-styles.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Uncial+Antiqua&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #0f0c29, #24243e, #302b63);
            background-attachment: fixed;
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(212, 175, 55, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 80% 20%, rgba(255, 215, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(138, 43, 226, 0.08) 0%, transparent 70%),
                url('data:image/svg+xml,<svg width="60" height="60" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="stars" x="0" y="0" width="60" height="60" patternUnits="userSpaceOnUse"><circle cx="15" cy="15" r="1" fill="%23ffffff" opacity="0.1"/><circle cx="45" cy="30" r="0.8" fill="%23ffd700" opacity="0.15"/><circle cx="30" cy="45" r="1.2" fill="%23ffffff" opacity="0.08"/></pattern></defs><rect width="100%" height="100%" fill="url(%23stars)"/></svg>');
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(212, 175, 55, 0.1));
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 25px;
            border: 2px solid rgba(255, 215, 0, 0.4);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.4),
                0 5px 15px rgba(255, 215, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .title {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 3.2em;
            background: linear-gradient(135deg, #ffd700, #ffed4e, #fff700, #ffd700);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            filter: 
                drop-shadow(0 3px 6px rgba(255, 215, 0, 0.4))
                drop-shadow(0 6px 12px rgba(0, 0, 0, 0.3));
            animation: titleGlow 4s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        @keyframes titleGlow {
            0%, 100% { 
                background-position: 0% 50%;
                filter: 
                    drop-shadow(0 3px 6px rgba(255, 215, 0, 0.4))
                    drop-shadow(0 6px 12px rgba(0, 0, 0, 0.3));
            }
            50% { 
                background-position: 100% 50%;
                filter: 
                    drop-shadow(0 5px 10px rgba(255, 215, 0, 0.6))
                    drop-shadow(0 10px 20px rgba(0, 0, 0, 0.4));
            }
        }

        .subtitle {
            font-size: 1.4em;
            color: #e6d7c3;
            opacity: 0.95;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 2;
        }

        .info-box {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .info-title {
            color: #4a90e2;
            font-size: 1.3em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-list {
            list-style: none;
            padding-left: 20px;
        }

        .info-list li {
            margin-bottom: 8px;
            color: #e0d0c0;
        }

        .game-mode {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-card {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.1), rgba(138, 43, 226, 0.05));
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 25px;
            padding: 35px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.2),
                0 3px 8px rgba(255, 215, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .mode-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(138, 43, 226, 0.02));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mode-card:hover::before {
            opacity: 1;
        }

        .mode-card:hover {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(138, 43, 226, 0.1));
            border-color: rgba(255, 215, 0, 0.6);
            transform: translateY(-12px) scale(1.03);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 8px 20px rgba(255, 215, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .mode-card.selected {
            background: rgba(212, 175, 55, 0.2);
            border-color: #f4e876;
        }

        .mode-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
            display: block;
        }

        .mode-title {
            font-size: 1.4em;
            color: #d4af37;
            margin-bottom: 10px;
        }

        .mode-description {
            color: #b8a082;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .multiplayer-setup {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            display: none;
        }

        .setup-title {
            color: #d4af37;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }

        .team-input {
            margin-bottom: 20px;
        }

        .team-input label {
            display: block;
            color: #b8a082;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .team-input input {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #6b4d37;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #f4f1e8;
            font-family: inherit;
        }

        .team-input input:focus {
            outline: none;
            border-color: #d4af37;
            background: rgba(0, 0, 0, 0.5);
        }

        .room-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .room-option {
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid #d4af37;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .room-option:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        .room-option-title {
            color: #d4af37;
            font-size: 1.2em;
            margin-bottom: 8px;
        }

        .room-option-desc {
            color: #b8a082;
            font-size: 0.9em;
        }

        .room-input-section {
            margin-bottom: 20px;
            display: none;
        }

        .room-input-section.active {
            display: block;
        }

        .complexity-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .complexity-content {
            background: linear-gradient(135deg, #2c1810, #4a3425);
            border: 3px solid #d4af37;
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .complexity-title {
            color: #d4af37;
            font-family: 'Uncial Antiqua', cursive;
            font-size: 2.2em;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .complexity-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .complexity-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #6b4d37;
            border-radius: 15px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .complexity-card:hover {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            transform: translateY(-5px);
        }

        .complexity-card.selected {
            border-color: #f4e876;
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }

        .complexity-icon {
            font-size: 3em;
            margin-bottom: 15px;
            display: block;
        }

        .complexity-name {
            color: #d4af37;
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .complexity-description {
            color: #b8a082;
            font-size: 0.95em;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .complexity-features {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .complexity-features li {
            color: #e0d0c0;
            font-size: 0.85em;
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }

        .complexity-features li:before {
            content: "✓";
            color: #d4af37;
            font-weight: bold;
            position: absolute;
            left: 0;
        }

        .complexity-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .room-code-display {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4a90e2;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 15px;
        }

        .room-code {
            font-size: 1.5em;
            color: #4a90e2;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .share-link {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #6b4d37;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
            color: #b8a082;
            word-break: break-all;
            margin-bottom: 10px;
        }

        .button {
            background: linear-gradient(135deg, #d4af37, #b8941f);
            color: #2c1810;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }

        .button:hover {
            background: linear-gradient(135deg, #f4e876, #d4af37);
            transform: translateY(-2px);
        }

        .button.secondary {
            background: rgba(108, 77, 55, 0.8);
            color: #f4f1e8;
            border: 2px solid #6b4d37;
        }

        .button.secondary:hover {
            background: rgba(108, 77, 55, 1);
            border-color: #8b6d47;
        }

        .lobby {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #4a90e2;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            display: none;
        }

        .lobby-title {
            color: #4a90e2;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }

        .teams-list {
            margin-bottom: 20px;
        }

        .team-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #6b4d37;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .team-name {
            color: #d4af37;
            font-weight: 600;
        }

        .team-status {
            color: #4a90e2;
            font-size: 0.9em;
        }

        .game-container {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .game-options {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #6b4d37;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .option-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #b8a082;
            font-size: 0.9em;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #6b4d37;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #f4f1e8;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #d4af37;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .option-description {
            font-size: 0.8em;
            color: #8b7355;
            margin-left: 5px;
        }

        /* Drag and Drop Styles */
        .drag-drop-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #6b4d37;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
        }

        .drag-item {
            background: linear-gradient(135deg, #4a3425, #6b4d37);
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 15px;
            margin: 8px;
            cursor: grab;
            transition: all 0.3s ease;
            color: #f4f1e8;
            text-align: center;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .drag-item:hover {
            background: linear-gradient(135deg, #6b4d37, #8b6d47);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(212, 175, 55, 0.3);
        }

        .drag-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .drop-zone {
            min-height: 60px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px dashed #6b4d37;
            border-radius: 8px;
            margin: 5px 0;
            padding: 10px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8b7355;
        }

        .drop-zone.drag-over {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            color: #d4af37;
        }

        .drop-zone.filled {
            border-style: solid;
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.15);
        }

        .chronology-timeline {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .scripture-topics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .topic-section {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #6b4d37;
            border-radius: 10px;
            padding: 15px;
        }

        .topic-title {
            color: #d4af37;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .items-pool {
            background: rgba(212, 175, 55, 0.05);
            border: 2px solid #d4af37;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            min-height: 100px;
        }

        .pool-title {
            color: #d4af37;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .timer {
            font-size: 1.5em;
            color: #d4af37;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #d4af37;
        }

        .progress-container {
            flex: 1;
            min-width: 200px;
        }

        .progress-label {
            color: #b8a082;
            margin-bottom: 8px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid #6b4d37;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #f4e876);
            width: 0%;
            transition: width 0.3s ease;
        }

        .seals-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .seal {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #8b0000;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .seal:hover {
            border-color: #d4af37;
            transform: translateY(-5px);
        }

        .seal.opened {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
        }

        .seal-number {
            font-size: 3em;
            color: #8b0000;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px auto;
            border: 2px solid #8b0000;
        }

        .seal.opened .seal-number {
            color: #d4af37;
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.2);
        }

        .seal-title {
            color: #f4f1e8;
            font-weight: 600;
        }

        .leaderboard {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 20px;
        }

        .leaderboard-title {
            color: #d4af37;
            font-size: 1.3em;
            margin-bottom: 15px;
            text-align: center;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .leaderboard-rank {
            color: #d4af37;
            font-weight: bold;
            width: 30px;
        }

        .leaderboard-name {
            flex: 1;
            color: #f4f1e8;
        }

        .leaderboard-score {
            color: #4a90e2;
            font-weight: 600;
        }

        .puzzle-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .puzzle-content {
            background: linear-gradient(135deg, #2c1810, #4a3425);
            border: 3px solid #d4af37;
            border-radius: 20px;
            padding: 30px;
            max-width: 95vw;
            width: 95vw;
            max-height: 95vh;
            overflow-y: auto;
            position: relative;
            box-sizing: border-box;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .puzzle-content {
                padding: 20px;
                max-width: 98vw;
                width: 98vw;
                max-height: 98vh;
                border-radius: 15px;
                margin: 1vh auto;
            }
            
            .modal-header {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .puzzle-title {
                font-size: 1.4em;
                text-align: center;
            }
            
            .close-button {
                align-self: flex-end;
                width: 40px;
                height: 40px;
                font-size: 1.3em;
            }
        }

        /* Enhanced scrolling for chronological challenges */
        .chronology-timeline {
            max-height: 60vh;
            overflow-y: auto;
            border: 2px solid #d4af37;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            min-height: 200px;
        }

        .chronology-events {
            max-height: 40vh;
            overflow-y: auto;
            border: 2px solid #8b6914;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            background: rgba(139, 105, 20, 0.2);
            min-height: 150px;
        }

        /* Mobile improvements for drag and drop */
        @media (max-width: 768px) {
            .chronology-timeline,
            .chronology-events {
                max-height: 35vh;
                min-height: 120px;
                padding: 10px;
                margin: 10px 0;
            }
            
            .draggable-item {
                padding: 15px !important;
                margin: 8px 0 !important;
                font-size: 0.9em !important;
                touch-action: none;
                cursor: grab;
            }
            
            .draggable-item:active {
                cursor: grabbing;
            }
            
            .drop-zone {
                min-height: 60px !important;
                padding: 12px !important;
                margin: 5px 0 !important;
            }
            
            .challenge-controls {
                flex-direction: column;
                gap: 10px;
                margin-top: 20px;
            }
            
            .btn {
                width: 100%;
                padding: 15px;
                font-size: 1.1em;
            }
        }

        /* Improved scrollbar styling for drag areas */
        .chronology-timeline::-webkit-scrollbar,
        .chronology-events::-webkit-scrollbar {
            width: 8px;
        }

        .chronology-timeline::-webkit-scrollbar-track,
        .chronology-events::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .chronology-timeline::-webkit-scrollbar-thumb,
        .chronology-events::-webkit-scrollbar-thumb {
            background: #d4af37;
            border-radius: 4px;
        }

        .chronology-timeline::-webkit-scrollbar-thumb:hover,
        .chronology-events::-webkit-scrollbar-thumb:hover {
            background: #f4e876;
        }

        /* Visual hint for scrollable areas */
        .chronology-timeline::before,
        .chronology-events::before {
            content: "📜 Scroll to see all items";
            display: block;
            text-align: center;
            color: #d4af37;
            font-size: 0.9em;
            margin-bottom: 10px;
            opacity: 0.7;
        }

        /* Spiritual Footer Styles */
        .spiritual-footer {
            background: linear-gradient(135deg, #1a1a1a, #2c1810);
            border-top: 3px solid #d4af37;
            padding: 30px 20px;
            margin-top: 50px;
            min-height: 200px;
        }

        .inspiration-container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 300px;
            gap: 30px;
            align-items: start;
        }

        .scripture-motivation,
        .ministerial-wisdom {
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .scripture-motivation:hover,
        .ministerial-wisdom:hover {
            background: rgba(212, 175, 55, 0.2);
            border-color: rgba(212, 175, 55, 0.5);
            transform: translateY(-2px);
        }

        .scripture-text,
        .wisdom-text {
            color: #f4f1e8;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
            font-style: italic;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .scripture-reference,
        .wisdom-attribution {
            color: #d4af37;
            font-weight: bold;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .worship-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .worship-btn {
            background: linear-gradient(145deg, #d4af37, #b8941f);
            color: #1a1a1a;
            border: none;
            border-radius: 25px;
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .worship-btn:hover {
            background: linear-gradient(145deg, #f4e876, #d4af37);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .worship-btn.playing {
            background: linear-gradient(145deg, #28a745, #20a83a);
            color: white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3); }
            50% { box-shadow: 0 6px 25px rgba(40, 167, 69, 0.6); }
            100% { box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3); }
        }

        .now-playing {
            background: rgba(0, 0, 0, 0.4);
            color: #d4af37;
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            text-align: center;
            font-size: 0.9em;
            animation: nowPlayingGlow 3s ease-in-out infinite;
        }

        @keyframes nowPlayingGlow {
            0% { border-color: rgba(212, 175, 55, 0.3); }
            50% { border-color: rgba(212, 175, 55, 0.7); }
            100% { border-color: rgba(212, 175, 55, 0.3); }
        }

        /* Responsive design for spiritual footer */
        @media (max-width: 768px) {
            .inspiration-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .scripture-motivation,
            .ministerial-wisdom {
                padding: 20px;
            }
            
            .scripture-text,
            .wisdom-text {
                font-size: 1em;
            }

            /* Mobile game layout improvements */
            .seals-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 15px !important;
                padding: 15px !important;
            }

            .seal {
                min-height: 120px !important;
                padding: 15px 10px !important;
                font-size: 0.9em !important;
            }

            .game-options {
                flex-direction: column !important;
                gap: 15px !important;
                padding: 20px !important;
            }

            .option-toggle {
                flex-direction: column !important;
                align-items: stretch !important;
                text-align: center !important;
                gap: 10px !important;
            }

            .progress-container {
                flex-direction: column !important;
                gap: 10px !important;
                text-align: center !important;
            }

            .timer {
                font-size: 1.5em !important;
                margin-bottom: 15px !important;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-button {
            background: rgba(220, 53, 69, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .close-button:hover {
            background: rgba(220, 53, 69, 1);
            transform: scale(1.1);
        }

        .puzzle-title {
            color: #d4af37;
            font-size: 1.8em;
            margin-bottom: 20px;
        }

        .puzzle-question {
            color: #f4f1e8;
            font-size: 1.1em;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .puzzle-input {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: 2px solid #6b4d37;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #f4f1e8;
            font-family: inherit;
            margin-bottom: 20px;
        }

        .puzzle-input:focus {
            outline: none;
            border-color: #d4af37;
        }

        .puzzle-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .alert.success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .alert.error {
            background: linear-gradient(135deg, #dc3545, #fd7e14);
        }

        .alert.show {
            opacity: 1;
            transform: translateX(0);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 1000;
            opacity: 0.8;
        }

        .connected {
            background: rgba(34, 139, 34, 0.8);
            color: white;
        }

        .disconnected {
            background: rgba(220, 53, 69, 0.8);
            color: white;
        }

        .connecting {
            background: rgba(255, 193, 7, 0.8);
            color: black;
        }

        @media (max-width: 768px) {
            .game-mode {
                grid-template-columns: 1fr;
            }

            .room-options {
                grid-template-columns: 1fr;
            }

            .game-header {
                flex-direction: column;
                text-align: center;
            }

            .seals-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
        }
    </style>
</head>

<body>
    <div class="connection-status connecting" id="connectionStatus">
        🔄 Connecting to Firebase...
    </div>

    <div class="container">
        <div class="header">
            <h1 class="title">🔮 The Scroll of Seven Seals</h1>
            <p class="subtitle">Real-time Firebase Multiplayer Bible Mystery Adventure</p>
        </div>

        <div class="info-box">
            <div class="info-title">
                🌐 Real Cross-Device Multiplayer:
            </div>
            <ol class="info-list">
                <li><strong>Create room →</strong> Get a shareable link</li>
                <li><strong>Share link with friends</strong> on different devices</li>
                <li><strong>Everyone clicks the same link to join</strong></li>
                <li><strong>Compete in real-time across the internet!</strong></li>
            </ol>
        </div>

        <!-- Game Mode Selection -->
        <div id="modeSelection" class="game-mode">
            <div class="mode-card" onclick="selectMode('single')">
                <span class="mode-icon">🏠</span>
                <div class="mode-title">Single Group</div>
                <div class="mode-description">Play as one team and beat your best time</div>
            </div>

            <div class="mode-card" onclick="selectMode('ai')">
                <span class="mode-icon">🤖</span>
                <div class="mode-title">VS Computer Teams</div>
                <div class="mode-description">Compete against AI opponents</div>
            </div>

            <div class="mode-card" onclick="selectMode('multiplayer')">
                <span class="mode-icon">🌐</span>
                <div class="mode-title">Real Multiplayer</div>
                <div class="mode-description">Compete with friends online using Firebase</div>
            </div>
        </div>

        <!-- Multiplayer Setup -->
        <div id="multiplayerSetup" class="multiplayer-setup">
            <div class="setup-title">Firebase Real-time Multiplayer Setup</div>

            <div class="team-input">
                <label for="teamName">Team Name:</label>
                <input type="text" id="teamName" placeholder="Enter your team name" maxlength="20">
            </div>

            <div class="room-options">
                <div class="room-option" onclick="showRoomCreation()">
                    <div class="room-option-title">🏠 Create Room</div>
                    <div class="room-option-desc">Start a new Firebase game room</div>
                </div>

                <div class="room-option" onclick="showRoomJoin()">
                    <div class="room-option-title">🔗 Join via Link</div>
                    <div class="room-option-desc">Use a friend's room link</div>
                </div>
            </div>

            <div id="roomCreation" class="room-input-section">
                <div class="room-code-display">
                    <div>Room Code:</div>
                    <div class="room-code" id="roomCode">------</div>
                </div>
                <div class="room-code-display">
                    <div>Your Room Link:</div>
                    <div class="share-link" id="shareLink">Click Create Room to generate link...</div>
                </div>
                <button class="button" onclick="copyRoomLink()">📋 Copy Room Link</button>
                <button class="button" onclick="createRoom()">Create Room</button>
            </div>

            <div id="roomJoin" class="room-input-section">
                <div class="team-input">
                    <label>Paste Room Link or Code:</label>
                    <input type="text" id="roomInput" placeholder="Paste room link from your friend">
                </div>
                <button class="button" onclick="joinRoom()">Join Room</button>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="button secondary" onclick="goBack()">← Back</button>
            </div>
        </div>

        <!-- AI Mode Setup -->
        <div id="aiSetup" class="multiplayer-setup" style="display: none;">
            <div class="setup-title">🤖 VS Computer Teams Setup</div>

            <div class="team-input">
                <label for="playerTeamName">Your Team Name:</label>
                <input type="text" id="playerTeamName" placeholder="Enter your team name" maxlength="20" value="Player">
            </div>

            <div class="team-input">
                <label for="aiTeamCount">Number of AI Opponents:</label>
                <select id="aiTeamCount" style="width: 100%; padding: 12px; font-size: 1em; border: 2px solid #6b4d37; border-radius: 8px; background: rgba(0, 0, 0, 0.3); color: #f4f1e8; font-family: inherit;">
                    <option value="1">1 AI Team</option>
                    <option value="2" selected>2 AI Teams</option>
                    <option value="3">3 AI Teams</option>
                    <option value="4">4 AI Teams</option>
                    <option value="5">5 AI Teams</option>
                </select>
            </div>

            <div class="team-input">
                <label for="aiDifficulty">AI Difficulty:</label>
                <select id="aiDifficulty" style="width: 100%; padding: 12px; font-size: 1em; border: 2px solid #6b4d37; border-radius: 8px; background: rgba(0, 0, 0, 0.3); color: #f4f1e8; font-family: inherit;">
                    <option value="easy">🟢 Easy - AI completes seals every 45-90 seconds</option>
                    <option value="medium" selected>🟡 Medium - AI completes seals every 30-60 seconds</option>
                    <option value="hard">🔴 Hard - AI completes seals every 15-45 seconds</option>
                    <option value="expert">🔥 Expert - AI completes seals every 10-30 seconds</option>
                </select>
            </div>

            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #c9a96e; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h4 style="color: #d4af37; margin-bottom: 10px;">🎮 How it Works:</h4>
                <ul style="color: #e8dcc0; margin: 0; padding-left: 20px;">
                    <li>You compete against AI teams that solve seals automatically</li>
                    <li>First team (you or AI) to complete all 7 seals wins</li>
                    <li>Game ends immediately when someone wins</li>
                    <li>Final rankings show all teams' performance</li>
                </ul>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="button" onclick="startAIGame()">🚀 Start Competition</button>
                <button class="button secondary" onclick="goBack()">← Back</button>
            </div>
        </div>

        <!-- Lobby -->
        <div id="lobby" class="lobby">
            <div class="lobby-title">Firebase Game Lobby</div>
            <div class="room-code-display">
                <div>Room Code: <span class="room-code" id="lobbyRoomCode">------</span></div>
            </div>
            <div class="teams-list" id="teamsList"></div>
            <div style="text-align: center;">
                <button class="button" onclick="startRoomGameplay()" id="startLobbyBtn">Start Adventure</button>
                <button class="button secondary" onclick="goBack()">← Back to Setup</button>
            </div>
        </div>

        <!-- Game Container -->
        <div id="gameContainer" class="game-container">
            <div class="game-header">
                <div class="timer" id="timer">00:00</div>
                <div class="progress-container">
                    <div class="progress-label">Progress: <span id="progressText">0/7 Seals</span></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>

            <!-- Universal Game Options -->
            <div class="game-options">
                <div class="option-toggle">
                    <span>🔊 Sound Effects:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="soundEnabled" onchange="toggleSound()" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="option-description">Play audio feedback for game actions</span>
                </div>
                <div class="option-toggle">
                    <span>💡 Enhanced Hints:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="hintsEnabled" onchange="toggleHints()">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="option-description">Show additional guidance for challenging puzzles</span>
                </div>
                <div class="option-toggle">
                    <span>🔀 Random Mode:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="randomMode" checked onchange="toggleRandomMode()">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="option-description">Generate fresh puzzles each game</span>
                </div>
                <div class="option-toggle">
                    <span>📊 Show Progress:</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="detailedProgress" checked onchange="toggleDetailedProgress()">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="option-description">Display detailed completion statistics</span>
                </div>
            </div>

            <div class="seals-grid" id="sealsGrid"></div>

            <div class="leaderboard">
                <div class="leaderboard-title">Live Rankings</div>
                <div id="leaderboardList"></div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="button secondary" onclick="resetGameState()">🔄 Reset Game</button>
                <button class="button secondary" onclick="goBack()">← Back to Lobby</button>
            </div>
        </div>
    </div>

    <!-- Complexity Selection Modal -->
    <div id="complexityModal" class="complexity-modal">
        <div class="complexity-content">
            <h2 class="complexity-title">⚔️ Choose Your Challenge Level ⚔️</h2>
            <p style="text-align: center; color: #b8a082; margin-bottom: 30px; font-size: 1.1em;">
                Select the complexity level that matches your biblical knowledge and puzzle-solving experience
            </p>
            
            <div class="complexity-grid">
                <!-- Beginner Level -->
                <div class="complexity-card" onclick="selectComplexity('beginner')" data-complexity="beginner">
                    <span class="complexity-icon">🌱</span>
                    <div class="complexity-name">Beginner</div>
                    <div class="complexity-description">
                        Perfect for newcomers to biblical puzzles and those who prefer a gentle introduction to the mysteries.
                    </div>
                    <ul class="complexity-features">
                        <li>Enhanced hints and guidance available</li>
                        <li>More forgiving answer validation</li>
                        <li>Extra time for challenging puzzles</li>
                        <li>Simplified puzzle variations</li>
                        <li>Progress tracking and encouragement</li>
                    </ul>
                </div>

                <!-- Intermediate Level -->
                <div class="complexity-card" onclick="selectComplexity('intermediate')" data-complexity="intermediate">
                    <span class="complexity-icon">⚖️</span>
                    <div class="complexity-name">Intermediate</div>
                    <div class="complexity-description">
                        Balanced challenge for those with moderate biblical knowledge and puzzle-solving experience.
                    </div>
                    <ul class="complexity-features">
                        <li>Standard hints when needed</li>
                        <li>Balanced answer requirements</li>
                        <li>Normal time limits</li>
                        <li>Mixed puzzle complexity</li>
                        <li>Achievement tracking</li>
                    </ul>
                </div>

                <!-- Advanced Level -->
                <div class="complexity-card" onclick="selectComplexity('advanced')" data-complexity="advanced">
                    <span class="complexity-icon">🔥</span>
                    <div class="complexity-name">Advanced</div>
                    <div class="complexity-description">
                        Challenging experience for seasoned biblical scholars and puzzle enthusiasts seeking deeper mysteries.
                    </div>
                    <ul class="complexity-features">
                        <li>Limited hints available</li>
                        <li>Stricter answer validation</li>
                        <li>Shorter time limits</li>
                        <li>Complex puzzle variations</li>
                        <li>Bonus challenges unlocked</li>
                    </ul>
                </div>

                <!-- Expert Level -->
                <div class="complexity-card" onclick="selectComplexity('expert')" data-complexity="expert">
                    <span class="complexity-icon">👑</span>
                    <div class="complexity-name">Expert</div>
                    <div class="complexity-description">
                        Ultimate challenge for biblical masters who dare to unlock the deepest secrets of the Seven Seals.
                    </div>
                    <ul class="complexity-features">
                        <li>No hints or guidance</li>
                        <li>Exact answer requirements</li>
                        <li>Strict time constraints</li>
                        <li>Maximum puzzle complexity</li>
                        <li>Legendary achievements</li>
                    </ul>
                </div>
            </div>

            <div class="complexity-buttons">
                <button class="button" id="confirmComplexity" onclick="confirmComplexitySelection()" disabled>
                    🚀 Begin Quest
                </button>
                <button class="button secondary" onclick="closeComplexityModal()">
                    ← Back
                </button>
            </div>
        </div>
    </div>

    <!-- Enhanced Challenge Modal -->
    <div id="puzzleModal" class="puzzle-modal">
        <div class="puzzle-content">
            <div class="modal-header">
                <div class="puzzle-title" id="puzzleTitle"></div>
                <button class="close-button" onclick="closePuzzle()">✕</button>
            </div>
            <div class="puzzle-question" id="puzzleQuestion">
                <!-- Enhanced challenge content loads here -->
            </div>
            <!-- Legacy input - hidden by default for enhanced challenges -->
            <div id="legacyInputs" style="display: none;">
                <input type="text" id="puzzleAnswer" class="puzzle-input" placeholder="Enter your answer">
                <div class="puzzle-buttons">
                    <button class="button" onclick="submitAnswer()">Submit</button>
                    <button class="button secondary" onclick="closePuzzle()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Firebase directly
        const firebaseConfig = {
            apiKey: "AIzaSyB9eQyqDeIjQvCRDtVVEsImhsfXNA9xMRc",
            authDomain: "scroll-of-seven-seals.firebaseapp.com",
            databaseURL: "https://scroll-of-seven-seals-default-rtdb.firebaseio.com",
            projectId: "scroll-of-seven-seals",
            storageBucket: "scroll-of-seven-seals.firebasestorage.app",
            messagingSenderId: "156760249212",
            appId: "1:156760249212:web:1bf31ad5f92b410f29caf9",
            measurementId: "G-DPY2ZJ7CSD"
        };

        // VERSION CHECK - Force browser cache refresh
        console.log('🚀 GAME VERSION: v1.3.1 - FIXED NULL ERROR + IMMEDIATE WINNER');
        console.log('📅 Code loaded at:', new Date().toISOString());
        
        // EMERGENCY WINNER TESTING - Call from console if needed
        window.forcePlayerWin = function() {
            console.log('🆘 EMERGENCY: Forcing player victory manually');
            if (gameState.mode === 'ai' && gameState.completedSeals.length >= 7) {
                const elapsed = Date.now() - gameState.startTime;
                const playerTeam = gameState.teams.find(team => !team.isAI) || { name: gameState.currentTeam, isAI: false };
                playerTeam.score = 7;
                playerTeam.completedSeals = [...gameState.completedSeals];
                playerTeam.lastSealTime = Date.now();
                handleAIGameEnd(playerTeam, elapsed);
            }
        };
        
        // Game State
        let gameState = {
            mode: '',
            currentTeam: '',
            teams: [],
            completedSeals: [],
            startTime: null,
            currentPuzzle: null,
            isGameActive: false,
            roomCode: '',
            isHost: false,
            roomRef: null,
            // AI Mode specific
            aiTeams: [],
            aiTimers: [],
            aiDifficulty: 'medium'
        };

        // Ensure enhanced data is loaded
        function initializeEnhancedGame() {
            if (!window.GameData) {
                console.error('❌ GameData not loaded! Check console for script errors.');
                showAlert('Enhanced challenges failed to load!', 'error');
                return false;
            }
            if (!window.PuzzleManager) {
                console.error('❌ PuzzleManager not loaded! Check console for script errors.');
                showAlert('Enhanced challenges failed to load!', 'error');
                return false;
            }
            
            console.log('✅ Enhanced challenge system initialized');
            console.log('📚 Available seals:', window.GameData.seals.length);
            return true;
        }

        // Firebase connection monitoring
        let isFirebaseReady = false;
        let app, database, auth;

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `connection-status ${status}`;

            switch (status) {
                case 'connecting':
                    statusEl.textContent = '🔄 Connecting to Firebase...';
                    break;
                case 'connected':
                    statusEl.textContent = '✅ Firebase Connected';
                    isFirebaseReady = true;
                    setTimeout(() => statusEl.style.display = 'none', 3000);
                    break;
                case 'disconnected':
                    statusEl.textContent = '❌ Firebase Disconnected';
                    statusEl.style.display = 'block';
                    break;
            }
        }

        // Initialize Firebase
        function initializeFirebase() {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof firebase !== 'undefined') {
                        console.log('🔥 Firebase SDK loaded, initializing...');

                        // Check if already initialized
                        if (isFirebaseReady && database && auth) {
                            console.log('✅ Firebase already ready');
                            resolve(true);
                            return;
                        }

                        if (!app) {
                            app = firebase.initializeApp(firebaseConfig);
                        }
                        database = firebase.database();
                        auth = firebase.auth();

                        console.log('🔥 Firebase initialized successfully');

                        // Wait for authentication state
                        const unsubscribe = auth.onAuthStateChanged((user) => {
                            if (user) {
                                console.log('✅ User authenticated:', user.uid);
                                isFirebaseReady = true;
                                updateConnectionStatus('connected');
                                unsubscribe(); // Remove listener after first authentication
                                resolve(true);

                                // Monitor connection status
                                database.ref('.info/connected').on('value', (snapshot) => {
                                    const connected = snapshot.val();
                                    console.log('🔥 Firebase connection status:', connected);
                                    if (connected === true) {
                                        updateConnectionStatus('connected');
                                        isFirebaseReady = true;
                                    } else {
                                        updateConnectionStatus('disconnected');
                                        isFirebaseReady = false;
                                    }
                                });
                            } else {
                                // Sign in anonymously for multiplayer access
                                console.log('🔐 Signing in anonymously...');
                                auth.signInAnonymously()
                                    .catch((error) => {
                                        console.error('❌ Anonymous authentication failed:', error);
                                        updateConnectionStatus('disconnected');
                                        unsubscribe();
                                        reject(error);
                                    });
                            }
                        });
                    } else {
                        console.error('❌ Firebase SDK not loaded');
                        updateConnectionStatus('disconnected');
                        reject(new Error('Firebase SDK not available'));
                    }
                } catch (error) {
                    console.error('❌ Firebase initialization failed:', error);
                    updateConnectionStatus('disconnected');
                    reject(error);
                }
            });
        }

        // Wait for Firebase SDK to load
        function waitForFirebase() {
            if (typeof firebase !== 'undefined') {
                initializeFirebase();
            } else {
                setTimeout(waitForFirebase, 100);
            }
        }

        // Start Firebase initialization
        waitForFirebase();

        // Check for room parameter in URL
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            if (roomParam) {
                // Auto-fill join form
                document.getElementById('roomInput').value = roomParam;
                selectMode('multiplayer');
                showRoomJoin();
            }
        });

        function selectMode(mode) {
            gameState.mode = mode;

            // Update UI
            document.querySelectorAll('.mode-card').forEach(card => card.classList.remove('selected'));
            event.target.closest('.mode-card').classList.add('selected');

            if (mode === 'multiplayer') {
                if (!isFirebaseReady) {
                    showAlert('Firebase is not ready yet. Please wait a moment and try again.', 'error');
                    return;
                }
                document.getElementById('multiplayerSetup').style.display = 'block';
            } else if (mode === 'ai') {
                // Show AI mode setup
                document.getElementById('aiSetup').style.display = 'block';
            } else {
                // Start single player mode directly
                startSinglePlayerGame();
            }
        }

        function showRoomCreation() {
            document.getElementById('roomCreation').classList.add('active');
            document.getElementById('roomJoin').classList.remove('active');

            // Automatically generate room code and link when showing creation form
            const roomCode = Math.random().toString(36).substr(2, 6).toUpperCase();
            const shareLink = `${window.location.origin}${window.location.pathname}?room=${roomCode}`;

            document.getElementById('roomCode').textContent = roomCode;
            document.getElementById('shareLink').textContent = shareLink;

            // Store for when they actually create the room
            window.tempRoomCode = roomCode;
            window.tempShareLink = shareLink;
        }

        function showRoomJoin() {
            document.getElementById('roomJoin').classList.add('active');
            document.getElementById('roomCreation').classList.remove('active');
        }

        async function createRoom() {
            console.log('🎯 Create room clicked');

            const teamName = document.getElementById('teamName').value.trim();
            if (!teamName) {
                showAlert('Please enter a team name', 'error');
                return;
            }

            // Use pre-generated room code and link
            const roomCode = window.tempRoomCode || Math.random().toString(36).substr(2, 6).toUpperCase();
            const shareLink = window.tempShareLink || `${window.location.origin}${window.location.pathname}?room=${roomCode}`;
            console.log('🎲 Using room code:', roomCode);

            gameState.roomCode = roomCode;
            gameState.currentTeam = teamName;
            gameState.isHost = true;
            gameState.teams = [{ name: teamName, score: 0, completedSeals: [] }];

            try {
                // Ensure Firebase is ready before proceeding
                if (!isFirebaseReady) {
                    updateConnectionStatus('connecting');
                    await initializeFirebase();
                }

                if (database && isFirebaseReady) {
                    console.log('🔥 Attempting Firebase save...');

                    const roomData = {
                        code: roomCode,
                        host: teamName,
                        teams: {
                            [teamName]: {
                                name: teamName,
                                isHost: true,
                                joinTime: firebase.database.ServerValue.TIMESTAMP,
                                score: 0,
                                completedSeals: []
                            }
                        },
                        status: 'waiting',
                        gameStarted: false,
                        createdAt: firebase.database.ServerValue.TIMESTAMP
                    };

                    await database.ref(`rooms/${roomCode}`).set(roomData);
                    console.log('✅ Firebase save successful');
                    showAlert('Room created! Share the link to invite players.', 'success');
                } else {
                    console.log('⚠️ Creating room without Firebase');
                    showAlert('Room created locally (limited functionality)', 'success');
                }
            } catch (error) {
                console.error('❌ Error creating room:', error);
                showAlert('Room created (with sync issues)', 'success');
            }

            // Always proceed to lobby
            showLobby();
        }

        async function joinRoom() {
            const teamName = document.getElementById('teamName').value.trim();
            let roomInput = document.getElementById('roomInput').value.trim();

            if (!teamName) {
                showAlert('Please enter a team name', 'error');
                return;
            }

            // Extract room code from URL if provided
            let roomCode = roomInput;
            if (roomInput.includes('?room=')) {
                roomCode = roomInput.split('?room=')[1].split('&')[0];
            }

            if (!roomCode) {
                showAlert('Please enter a room code or link', 'error');
                return;
            }

            roomCode = roomCode.toUpperCase();
            
            // DEBUG: Add extensive logging
            console.log('🚪 JOINING ROOM - Room code:', roomCode);
            console.log('🔥 Firebase ready?', isFirebaseReady);
            console.log('📡 Database object:', database);

            try {
                // Ensure Firebase is ready before proceeding
                if (!isFirebaseReady) {
                    updateConnectionStatus('connecting');
                    showAlert('Connecting to room...', 'success');
                    await initializeFirebase();
                }

                if (!database || !isFirebaseReady) {
                    showAlert('Unable to connect to multiplayer service', 'error');
                    return;
                }

                console.log('🔍 Checking room:', roomCode);

                // Check if room exists
                console.log('🔍 Searching for room at path:', `rooms/${roomCode}`);
                const snapshot = await database.ref(`rooms/${roomCode}`).once('value');
                const roomData = snapshot.val();
                
                console.log('📊 Room data found:', roomData);
                console.log('📊 Snapshot exists:', snapshot.exists());
                
                // DEBUG: List all rooms to see what's in the database
                const allRoomsSnapshot = await database.ref('rooms').once('value');
                const allRooms = allRoomsSnapshot.val();
                console.log('📋 All rooms in database:', allRooms);

                if (!roomData) {
                    console.log('❌ Room not found for code:', roomCode);
                    showAlert('Room not found. Please check the room code.', 'error');
                    return;
                }
                
                console.log('✅ Room found successfully!');

                if (roomData.status !== 'waiting') {
                    showAlert('This game has already started.', 'error');
                    return;
                }

                // Check if team name already exists
                if (roomData.teams && roomData.teams[teamName]) {
                    showAlert('A team with this name already exists in the room.', 'error');
                    return;
                }

                // Join the room
                gameState.roomCode = roomCode;
                gameState.currentTeam = teamName;
                gameState.isHost = false;

                const teamData = {
                    name: teamName,
                    isHost: false,
                    joinTime: firebase.database.ServerValue.TIMESTAMP,
                    score: 0,
                    completedSeals: []
                };

                console.log('💾 Saving team data:', teamData);
                await database.ref(`rooms/${roomCode}/teams/${teamName}`).set(teamData);

                // Update URL
                window.history.pushState({}, '', `${window.location.pathname}?room=${roomCode}`);

                showLobby();
                showAlert('Joined room successfully!', 'success');

            } catch (error) {
                console.error('❌ Error joining room:', error);
                showAlert('Failed to join room: ' + error.message, 'error');
            }
        }

        function showLobby() {
            document.getElementById('multiplayerSetup').style.display = 'none';
            document.getElementById('lobby').style.display = 'block';
            document.getElementById('lobbyRoomCode').textContent = gameState.roomCode;

            // Listen for room updates
            gameState.roomRef = database.ref(`rooms/${gameState.roomCode}`);
            gameState.roomRef.on('value', (snapshot) => {
                const roomData = snapshot.val();
                if (roomData) {
                    updateLobby(roomData);

                    // CRITICAL: Update leaderboard with live Firebase data during gameplay
                    if (gameState.isGameActive && roomData.teams) {
                        console.log('📊 ROOM LISTENER: Updating leaderboard with live data');
                        updateLeaderboardFromFirebase(roomData.teams);
                    }

                    // Check if game started
                    if (roomData.gameStarted && !gameState.isGameActive) {
                        startRoomGameplay();
                    }

                    // Check if game has ended with a winner
                    if (roomData.status === 'finished' && roomData.winner && gameState.isGameActive) {
                        console.log('🏆 ROOM LISTENER: Game ended, winner detected:', roomData.winner);
                        console.log('🏆 ROOM LISTENER: Current team:', gameState.currentTeam);
                        console.log('🏆 ROOM LISTENER: Is game active?', gameState.isGameActive);
                        console.log('🏆 ROOM LISTENER: Final rankings available?', !!roomData.finalRankings);
                        
                        const isWinner = roomData.winner === gameState.currentTeam;
                        console.log('🏆 ROOM LISTENER: Is current team winner?', isWinner);
                        
                        // Show enhanced modal with rankings if available, otherwise fallback to simple modal
                        if (roomData.finalRankings) {
                            showWinnerModalWithRankings(roomData.winner, roomData.completionTime || 0, roomData.finalRankings, isWinner);
                        } else {
                            showWinnerModal(roomData.winner, roomData.completionTime || 0, isWinner);
                        }
                    } 
                    // Also check for gameActive flag to lock the game immediately
                    else if (roomData.gameActive === false && gameState.isGameActive) {
                        console.log('🔒 ROOM LISTENER: Game deactivated, locking UI');
                        lockGameInputs();
                        
                        // If there's winner data but status isn't finished yet, prepare for incoming winner announcement
                        if (roomData.winner) {
                            console.log('🏆 ROOM LISTENER: Winner exists, showing modal soon');
                            const isWinner = roomData.winner === gameState.currentTeam;
                            if (roomData.finalRankings) {
                                showWinnerModalWithRankings(roomData.winner, roomData.completionTime || 0, roomData.finalRankings, isWinner);
                            } else {
                                showWinnerModal(roomData.winner, roomData.completionTime || 0, isWinner);
                            }
                        }
                    }
                    else {
                        console.log('🔍 ROOM LISTENER: Room status:', roomData.status, 'Winner:', roomData.winner, 'Game active:', roomData.gameActive, 'Local game active:', gameState.isGameActive);
                    }
                } else {
                    showAlert('Room no longer exists', 'error');
                    goBack();
                }
            });
        }

        function updateLobby(roomData) {
            // Update teams list
            gameState.teams = Object.values(roomData.teams || {});
            updateTeamsList();

            // Update start button for host
            if (gameState.isHost) {
                const startBtn = document.getElementById('startLobbyBtn');
                const canStart = gameState.teams.length >= 1; // Allow single player start for testing
                startBtn.disabled = !canStart;
                startBtn.textContent = canStart ? 'Start Adventure' : 'Waiting for players...';
            } else {
                const startBtn = document.getElementById('startLobbyBtn');
                startBtn.style.display = 'none';
            }
        }

        function updateTeamsList() {
            const teamsList = document.getElementById('teamsList');
            teamsList.innerHTML = '';

            gameState.teams.forEach(team => {
                const teamItem = document.createElement('div');
                teamItem.className = 'team-item';
                teamItem.innerHTML = `
                    <span class="team-name">${team.name}${team.isHost ? ' 👑' : ''}</span>
                    <span class="team-status">Ready</span>
                `;
                teamsList.appendChild(teamItem);
            });
        }

        function startRoomGameplay() {
            if (gameState.isHost) {
                // Host starts the game for everyone
                database.ref(`rooms/${gameState.roomCode}`).update({
                    gameStarted: true,
                    gameActive: true,
                    status: 'playing',
                    startTime: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // Initialize enhanced game system
            if (!initializeEnhancedGame()) {
                showAlert('Failed to load enhanced challenges!', 'error');
                return;
            }

            // Start local game
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            gameState.isGameActive = true;
            gameState.startTime = Date.now();
            gameState.completedSeals = [];

            renderSeals();
            startTimer();
            updateProgress();
            updateLeaderboard();

            showAlert('Game started!', 'success');
        }

        function startSinglePlayerGame() {
            // Initialize enhanced game system
            if (!initializeEnhancedGame()) {
                showAlert('Failed to load enhanced challenges!', 'error');
                return;
            }
            
            // Update spiritual content for fresh inspiration
            updateSpiritualContent();
            
            gameState.currentTeam = 'Player';
            gameState.teams = [{ name: 'Player', score: 0, completedSeals: [] }];

            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            gameState.isGameActive = true;
            gameState.startTime = Date.now();
            gameState.completedSeals = [];

            renderSeals();
            startTimer();
            updateProgress();
            updateLeaderboard();
        }

        // AI team name pool
        const aiTeamNames = [
            'Scripture Scholars', 'Bible Blazers', 'Faith Warriors', 'Gospel Guardians',
            'Verse Virtuosos', 'Holy Hunters', 'Divine Detectives', 'Sacred Seekers',
            'Truth Trackers', 'Word Warriors', 'Righteous Runners', 'Glory Gatherers',
            'Heaven Hounds', 'Salvation Squad', 'Psalm Pioneers', 'Covenant Crusaders',
            'Prophecy Pros', 'Testament Titans', 'Miracle Masters', 'Grace Gladiators'
        ];

        // AI difficulty settings
        const aiDifficultySettings = {
            easy: { minTime: 45000, maxTime: 90000, variance: 0.3 },      // 45-90 seconds
            medium: { minTime: 30000, maxTime: 60000, variance: 0.4 },    // 30-60 seconds  
            hard: { minTime: 15000, maxTime: 45000, variance: 0.5 },      // 15-45 seconds
            expert: { minTime: 10000, maxTime: 30000, variance: 0.6 }     // 10-30 seconds
        };

        function startAIGame() {
            const playerTeamName = document.getElementById('playerTeamName').value.trim() || 'Player';
            const aiTeamCount = parseInt(document.getElementById('aiTeamCount').value);
            const aiDifficulty = document.getElementById('aiDifficulty').value;

            if (!playerTeamName) {
                showAlert('Please enter your team name', 'error');
                return;
            }

            console.log('🤖 Starting AI Game:', { playerTeamName, aiTeamCount, aiDifficulty });

            // Initialize enhanced game system
            if (!initializeEnhancedGame()) {
                showAlert('Failed to load enhanced challenges!', 'error');
                return;
            }
            
            // Setup game state
            gameState.mode = 'ai';
            gameState.currentTeam = playerTeamName;
            gameState.aiDifficulty = aiDifficulty;
            gameState.completedSeals = [];
            gameState.aiTeams = [];
            gameState.aiTimers = [];

            // Create player team
            const playerTeam = { 
                name: playerTeamName, 
                score: 0, 
                completedSeals: [], 
                isAI: false,
                lastSealTime: null
            };

            // Create AI teams
            const selectedAINames = aiTeamNames
                .sort(() => Math.random() - 0.5)  // Shuffle
                .slice(0, aiTeamCount);           // Take required number

            const aiTeams = selectedAINames.map(name => ({
                name: name,
                score: 0,
                completedSeals: [],
                isAI: true,
                lastSealTime: null,
                nextSealTime: null
            }));

            // Combine all teams
            gameState.teams = [playerTeam, ...aiTeams];
            gameState.aiTeams = aiTeams;

            console.log('🤖 Teams created:', gameState.teams);

            // Hide setup and show game
            document.getElementById('aiSetup').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            // Start game
            gameState.isGameActive = true;
            gameState.startTime = Date.now();

            renderSeals();
            startTimer();
            updateProgress();
            updateLeaderboard();

            // Start AI progression
            startAIProgression();

            showAlert(`🤖 Competition started against ${aiTeamCount} AI team${aiTeamCount > 1 ? 's' : ''}!`, 'success');
        }

        function startAIProgression() {
            console.log('🤖 Starting AI progression with difficulty:', gameState.aiDifficulty);
            
            const settings = aiDifficultySettings[gameState.aiDifficulty];
            
            gameState.aiTeams.forEach((aiTeam, index) => {
                // Schedule first seal for each AI team with some initial delay and randomization
                const initialDelay = (index + 1) * 2000 + Math.random() * 5000; // 2-7 seconds staggered start
                
                setTimeout(() => {
                    if (gameState.isGameActive) {
                        scheduleNextAISeal(aiTeam);
                    }
                }, initialDelay);
            });
        }

        function scheduleNextAISeal(aiTeam) {
            // Enhanced check to prevent scheduling after game ends
            if (!gameState.isGameActive) {
                console.log(`🛑 Not scheduling next seal for ${aiTeam.name} - game inactive`);
                return;
            }
            
            if (aiTeam.score >= 7) {
                console.log(`🛑 Not scheduling next seal for ${aiTeam.name} - already completed`);
                return;
            }

            const settings = aiDifficultySettings[gameState.aiDifficulty];
            
            // Calculate next seal time with variance
            const baseTime = settings.minTime + Math.random() * (settings.maxTime - settings.minTime);
            const variance = (Math.random() - 0.5) * 2 * settings.variance; // -variance to +variance
            const nextSealTime = baseTime * (1 + variance);
            
            console.log(`🤖 ${aiTeam.name} next seal in ${Math.round(nextSealTime/1000)}s`);
            
            const timer = setTimeout(() => {
                // Triple check before executing - game state can change
                if (gameState.isGameActive && aiTeam.score < 7) {
                    completeAISeal(aiTeam);
                } else {
                    console.log(`🛑 ${aiTeam.name} timer fired but game inactive or team completed`);
                }
            }, nextSealTime);
            
            // Store timer for cleanup only if game is still active
            if (gameState.isGameActive) {
                gameState.aiTimers.push(timer);
                aiTeam.nextSealTime = Date.now() + nextSealTime;
            } else {
                // Clear the timer immediately if game became inactive
                clearTimeout(timer);
            }
        }

        function completeAISeal(aiTeam) {
            // CRITICAL: Double check game is still active - player might have won
            if (!gameState.isGameActive) {
                console.log(`🛑 ${aiTeam.name} seal completion cancelled - game already ended`);
                return;
            }
            
            if (aiTeam.score >= 7) {
                console.log(`🛑 ${aiTeam.name} already completed all seals`);
                return;
            }

            const sealNumber = aiTeam.score + 1;
            aiTeam.score = sealNumber;
            aiTeam.completedSeals.push(sealNumber);
            aiTeam.lastSealTime = Date.now();

            console.log(`🤖 ${aiTeam.name} completed seal ${sealNumber}!`);

            // Update UI only if game is still active
            if (gameState.isGameActive) {
                updateLeaderboard();
            }

            // Check for winner - but only if game is still active
            if (sealNumber === 7 && gameState.isGameActive) {
                console.log(`🏆 AI team ${aiTeam.name} completed all seals!`);
                const completionTime = Date.now() - gameState.startTime;
                
                // Final check before declaring AI winner - ensure player hasn't already won
                const playerTeam = gameState.teams.find(team => !team.isAI);
                if (playerTeam && playerTeam.score >= 7) {
                    console.log(`🛑 Player already won - ignoring AI completion`);
                    return;
                }
                
                handleAIGameEnd(aiTeam, completionTime);
            } else if (gameState.isGameActive) {
                // Schedule next seal only if game is still active
                scheduleNextAISeal(aiTeam);
            }
        }

        function handleAIGameEnd(winningTeam, completionTime) {
            console.log('🏆 handleAIGameEnd called');
            console.log('🏆 AI Game ended, winner:', winningTeam ? winningTeam.name : 'Unknown');
            console.log('🏆 Winning team details:', winningTeam);
            console.log('🏆 Completion time:', completionTime);
            console.log('🏆 Current teams state:', gameState.teams);
            
            // Ensure game is marked as inactive
            gameState.isGameActive = false;
            
            // Clear all AI timers to stop further AI progression
            if (gameState.aiTimers && gameState.aiTimers.length > 0) {
                console.log('🛑 Clearing', gameState.aiTimers.length, 'AI timers');
                gameState.aiTimers.forEach(timer => clearTimeout(timer));
                gameState.aiTimers = [];
            }
            
            // Calculate final rankings
            console.log('📊 Calculating final rankings...');
            const finalRankings = calculateAIFinalRankings();
            console.log('📊 Final rankings calculated:', finalRankings);
            
            // Show winner modal with rankings
            const isPlayerWinner = !winningTeam.isAI;
            console.log('🎉 Showing winner modal - Is player winner?', isPlayerWinner);
            console.log('🎉 Winner team name:', winningTeam.name);
            console.log('🎉 Final rankings:', finalRankings);
            
            try {
                // Force display of winner modal
                console.log('🚀 FORCING WINNER MODAL DISPLAY');
                showWinnerModalWithRankings(winningTeam.name, completionTime, finalRankings, isPlayerWinner);
                console.log('✅ Winner modal displayed successfully');
            } catch (error) {
                console.error('❌ Error showing winner modal:', error);
                console.error('❌ Error details:', error.stack);
                
                // Enhanced fallback - show both alert and try simple modal
                showAlert(`🏆 GAME OVER! ${winningTeam.name} WINS! Time: ${Math.floor(completionTime/60000)}:${Math.floor((completionTime%60000)/1000).toString().padStart(2,'0')}`, 'success');
                
                // Try showing the simple winner modal as backup
                try {
                    showWinnerModal(winningTeam.name, completionTime, isPlayerWinner);
                } catch (fallbackError) {
                    console.error('❌ Fallback modal also failed:', fallbackError);
                }
            }
            
            // Lock game inputs
            console.log('🔒 Locking game inputs...');
            lockGameInputs();
            console.log('✅ AI game end handling complete');
        }

        function calculateAIFinalRankings() {
            console.log('📊 Calculating AI game final rankings');
            
            const rankings = gameState.teams.map(team => ({
                teamName: team.name,
                sealsCompleted: team.score,
                completionTime: team.score === 7 ? (Date.now() - gameState.startTime) : null,
                lastSealTime: team.lastSealTime || Date.now(),
                completed: team.score === 7,
                isAI: team.isAI || false
            }));

            // Sort rankings: completed first, then by seals, then by completion/last seal time
            rankings.sort((a, b) => {
                if (a.completed && !b.completed) return -1;
                if (!a.completed && b.completed) return 1;
                
                if (a.sealsCompleted !== b.sealsCompleted) {
                    return b.sealsCompleted - a.sealsCompleted;
                }
                
                if (a.completed && b.completed && a.completionTime && b.completionTime) {
                    return a.completionTime - b.completionTime;
                }
                
                if (a.lastSealTime && b.lastSealTime) {
                    return a.lastSealTime - b.lastSealTime;
                }
                
                return 0;
            });

            rankings.forEach((team, index) => {
                team.rank = index + 1;
            });

            console.log('🏆 AI Final rankings:', rankings);
            return rankings;
        }

        // Old question system removed - using enhanced challenges from game-data.js

        // Use enhanced seals from game-data.js - no redeclaration needed
        function getSeals() {
            return window.GameData ? window.GameData.seals : [];
        }

        function renderSeals() {
            const sealsGrid = document.getElementById('sealsGrid');
            sealsGrid.innerHTML = '';

            const seals = getSeals();
            seals.forEach(seal => {
                const sealElement = document.createElement('div');
                sealElement.className = `seal ${gameState.completedSeals.includes(seal.id) ? 'opened' : ''}`;
                sealElement.setAttribute('data-challenge-type', seal.challengeType);
                sealElement.setAttribute('data-seal-id', seal.id);
                sealElement.onclick = () => openSeal(seal.id);

                sealElement.innerHTML = `
                    <div class="seal-number">${seal.id}</div>
                    <div class="seal-title">${seal.title}</div>
                    <div class="seal-theme">${seal.theme}</div>
                    <div class="challenge-type-indicator">${seal.challengeType}</div>
                `;

                sealsGrid.appendChild(sealElement);
            });
        }



        // Enhanced seal completion function for new challenge system
        function completeSeal(sealId) {
            console.log('🔓 Completing seal:', sealId);
            
            if (!gameState.completedSeals.includes(sealId)) {
                gameState.completedSeals.push(sealId);
                console.log('✅ Seal completed, total seals:', gameState.completedSeals.length);
                
                // Update progress
                updateProgress();
                renderSeals();
                
                // Close the modal
                document.getElementById('puzzleModal').style.display = 'none';
                
                // Check if all seals are completed
                if (gameState.completedSeals.length === 7) {
                    finishGame();
                }
                
                // For multiplayer, update Firebase
                if (gameState.roomCode && database) {
                    updateMultiplayerProgress();
                }
            }
        }

        // Make completeSeal available globally for the enhanced challenge system
        window.completeSeal = completeSeal;

        function submitAnswer() {
            // Check if game is still active
            if (!gameState.isGameActive) {
                showAlert('Game has ended. No more answers can be submitted!', 'error');
                closePuzzle();
                return;
            }
            
            const answer = document.getElementById('puzzleAnswer').value.trim().toLowerCase();
            const correctAnswers = gameState.currentPuzzle.answer;

            if (correctAnswers.some(correct => answer.includes(correct))) {
                // Correct answer
                gameState.completedSeals.push(gameState.currentPuzzle.number);

                // Update team score
                const currentTeam = gameState.teams.find(team => team.name === gameState.currentTeam);
                if (currentTeam) {
                    currentTeam.score = gameState.completedSeals.length;
                    currentTeam.completedSeals = [...gameState.completedSeals];
                    // For AI mode, also update lastSealTime for proper ranking
                    if (gameState.mode === 'ai') {
                        currentTeam.lastSealTime = Date.now();
                    }
                }

                console.log('🎯 SEAL COMPLETED - Mode:', gameState.mode, 'Team:', gameState.currentTeam, 'Score:', gameState.completedSeals.length);
                
                // AGGRESSIVE IMMEDIATE WINNER CHECK - FIRST PRIORITY BEFORE ANYTHING ELSE
                if (gameState.mode === 'ai' && gameState.completedSeals.length === 7) {
                    console.log('🚨 IMMEDIATE AI MODE WIN DETECTED - FORCING WINNER MODAL NOW!');
                    
                    // Stop everything immediately
                    gameState.isGameActive = false;
                    
                    // Clear all AI timers
                    if (gameState.aiTimers) {
                        gameState.aiTimers.forEach(timer => clearTimeout(timer));
                        gameState.aiTimers = [];
                    }
                    
                    // Force immediate winner handling
                    const elapsed = Date.now() - gameState.startTime;
                    const playerTeam = gameState.teams.find(team => !team.isAI) || { 
                        name: gameState.currentTeam, 
                        isAI: false, 
                        score: 7,
                        completedSeals: [...gameState.completedSeals],
                        lastSealTime: Date.now()
                    };
                    
                    console.log('🏆 CALLING DIRECT WINNER MODAL DISPLAY');
                    
                    // Calculate rankings immediately
                    const finalRankings = gameState.teams.map(team => ({
                        teamName: team.name,
                        sealsCompleted: team.name === gameState.currentTeam ? 7 : (team.score || 0),
                        completionTime: team.name === gameState.currentTeam ? elapsed : null,
                        lastSealTime: team.lastSealTime || Date.now(),
                        completed: team.name === gameState.currentTeam,
                        isAI: team.isAI || false,
                        rank: 0
                    })).sort((a, b) => {
                        if (a.completed && !b.completed) return -1;
                        if (!a.completed && b.completed) return 1;
                        if (a.sealsCompleted !== b.sealsCompleted) return b.sealsCompleted - a.sealsCompleted;
                        return (a.completionTime || 999999) - (b.completionTime || 999999);
                    }).map((team, index) => ({ ...team, rank: index + 1 }));
                    
                    // Show winner modal immediately
                    try {
                        showWinnerModalWithRankings(gameState.currentTeam, elapsed, finalRankings, true);
                        lockGameInputs();
                        console.log('✅ Winner modal displayed successfully - GAME WON!');
                    } catch (error) {
                        console.error('Winner modal failed:', error);
                        alert(`🏆 CONGRATULATIONS! You won in ${Math.floor(elapsed/60000)}:${Math.floor((elapsed%60000)/1000).toString().padStart(2,'0')}!`);
                    }
                    
                    return; // EXIT IMMEDIATELY - NO FURTHER CODE EXECUTION
                }

                // Update Firebase if in multiplayer (check for roomCode instead of mode)
                if (gameState.roomCode && gameState.currentTeam) {
                    console.log('🔥 UPDATING FIREBASE - Seal completed:', gameState.currentPuzzle.number);
                    console.log('🔥 Total seals completed:', gameState.completedSeals.length);
                    updateTeamProgressInFirebase();
                }

                closePuzzle();
                renderSeals();
                updateProgress();
                updateLeaderboard();

                showAlert(`Seal ${gameState.currentPuzzle ? gameState.currentPuzzle.number : 'Unknown'} opened!`, 'success');

                // Enhanced check for 7-seal completion
                console.log('🔍 CHECKING COMPLETION - Seals completed:', gameState.completedSeals.length, 'Total:', gameState.completedSeals);
                
                if (gameState.completedSeals.length === 7) {
                    console.log('🎉 TEAM COMPLETED ALL 7 SEALS!', gameState.currentTeam);
                    console.log('🎮 Game Mode:', gameState.mode);
                    console.log('🎮 Room code:', gameState.roomCode);
                    console.log('🔥 Is multiplayer?', !!gameState.roomCode);
                    console.log('🤖 Is AI mode?', gameState.mode === 'ai');
                    console.log('🏆 Is game still active?', gameState.isGameActive);
                    
                    // Enhanced AI mode handling with immediate winner declaration
                    if (gameState.mode === 'ai') {
                        console.log('🏆 AI MODE: Player wins by completing 7 seals first!');
                        
                        // CRITICAL: Immediately stop the game and clear all AI timers to prevent race conditions
                        gameState.isGameActive = false;
                        if (gameState.aiTimers && gameState.aiTimers.length > 0) {
                            console.log('🛑 EMERGENCY: Clearing', gameState.aiTimers.length, 'AI timers to prevent race condition');
                            gameState.aiTimers.forEach(timer => clearTimeout(timer));
                            gameState.aiTimers = [];
                        }
                        
                        // Force immediate winner handling for player
                        console.log('🚀 FORCING IMMEDIATE PLAYER VICTORY HANDLING');
                        const elapsed = Date.now() - gameState.startTime;
                        const playerTeam = gameState.teams.find(team => !team.isAI) || { name: gameState.currentTeam, isAI: false };
                        
                        // Update player team with completion data
                        if (playerTeam) {
                            playerTeam.score = 7;
                            playerTeam.completedSeals = [...gameState.completedSeals];
                            playerTeam.lastSealTime = Date.now();
                            console.log('✅ Final player team state:', playerTeam);
                        }
                        
                        // Immediate winner modal display
                        console.log('🏆 CALLING handleAIGameEnd IMMEDIATELY');
                        handleAIGameEnd(playerTeam, elapsed);
                        
                    } else {
                        console.log('📞 Calling finishGame() for non-AI mode');
                        finishGame();
                    }
                } else {
                    console.log('🔄 Not enough seals yet:', gameState.completedSeals.length, '< 7');
                }
            } else {
                showAlert('Incorrect answer. Try again!', 'error');
                document.getElementById('puzzleAnswer').focus();
            }
        }

        async function updateTeamProgressInFirebase() {
            if (!gameState.roomCode || !gameState.currentTeam) return;

            const teamData = {
                score: gameState.completedSeals.length,
                completedSeals: gameState.completedSeals,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP,
                lastSealTime: Date.now() // Track when this seal was completed for tiebreaking
            };

            console.log('💾 FIREBASE UPDATE: Updating team progress...', teamData);
            console.log('📍 FIREBASE UPDATE: Path:', `rooms/${gameState.roomCode}/teams/${gameState.currentTeam}`);

            try {
                await database.ref(`rooms/${gameState.roomCode}/teams/${gameState.currentTeam}`).update(teamData);
                console.log('✅ FIREBASE UPDATE: Team progress updated successfully');
                
                // CRITICAL: Check for winner after EACH seal completion, not just at the end
                if (gameState.completedSeals.length === 7 && gameState.isGameActive) {
                    console.log('🏆 FIREBASE UPDATE: Team completed 7 seals - checking for winner!');
                    const elapsed = Date.now() - gameState.startTime;
                    await checkForGameWinner(elapsed);
                }
            } catch (error) {
                console.error('❌ FIREBASE UPDATE: Failed to update team progress:', error);
            }
        }

        function closePuzzle() {
            document.getElementById('puzzleModal').style.display = 'none';
            gameState.currentPuzzle = null;
        }

        function updateProgress() {
            const completed = gameState.completedSeals.length;
            const total = 7; // Always 7 seals
            const percentage = (completed / total) * 100;

            document.getElementById('progressText').textContent = `${completed}/${total} Seals`;
            document.getElementById('progressFill').style.width = `${percentage}%`;
        }

        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';

            // Sort teams by score (descending)
            const sortedTeams = [...gameState.teams].sort((a, b) => b.score - a.score);

            sortedTeams.forEach((team, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                const isCurrentTeam = team.name === gameState.currentTeam;
                const teamLabel = isCurrentTeam ? ' (You)' : (team.isAI ? ' 🤖' : '');
                item.innerHTML = `
                    <span class="leaderboard-rank">#${index + 1}</span>
                    <span class="leaderboard-name">${team.name}${teamLabel}</span>
                    <span class="leaderboard-score">${team.score}/7</span>
                `;
                leaderboardList.appendChild(item);
            });
        }

        // CRITICAL: Update leaderboard with LIVE Firebase data for real-time sync
        function updateLeaderboardFromFirebase(firebaseTeams) {
            console.log('📊 FIREBASE LEADERBOARD: Updating with live data', firebaseTeams);
            
            const leaderboardList = document.getElementById('leaderboardList');
            if (!leaderboardList) {
                console.log('📊 FIREBASE LEADERBOARD: Leaderboard element not found');
                return;
            }
            
            leaderboardList.innerHTML = '';

            // Convert Firebase teams object to array and sort by score
            const teamsArray = Object.entries(firebaseTeams).map(([teamId, teamData]) => ({
                id: teamId,
                name: teamData.name || teamId,
                score: teamData.score || (teamData.completedSeals ? teamData.completedSeals.length : 0),
                completedSeals: teamData.completedSeals || [],
                isHost: teamData.isHost || false
            }));

            // Sort by score (descending)
            const sortedTeams = teamsArray.sort((a, b) => b.score - a.score);
            
            console.log('📊 FIREBASE LEADERBOARD: Sorted teams:', sortedTeams);

            sortedTeams.forEach((team, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                const isCurrentTeam = team.name === gameState.currentTeam;
                item.innerHTML = `
                    <span class="leaderboard-rank">#${index + 1}</span>
                    <span class="leaderboard-name">${team.name}${isCurrentTeam ? ' (YOU)' : ''}</span>
                    <span class="leaderboard-score">${team.score}/7</span>
                `;
                leaderboardList.appendChild(item);
            });
            
            console.log('📊 FIREBASE LEADERBOARD: Leaderboard updated successfully');
        }

        function startTimer() {
            const timerElement = document.getElementById('timer');

            setInterval(() => {
                if (gameState.isGameActive && gameState.startTime) {
                    const elapsed = Date.now() - gameState.startTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function finishGame() {
            console.log('🏁 finishGame() called');
            console.log('🎮 gameState.mode:', gameState.mode);
            console.log('👥 gameState.currentTeam:', gameState.currentTeam);
            console.log('📊 gameState.teams:', gameState.teams);
            console.log('🏆 gameState.isGameActive:', gameState.isGameActive);
            
            const elapsed = Date.now() - gameState.startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            if (gameState.mode === 'ai') {
                // AI mode - player won!
                console.log('🏆 AI mode - player completed all seals first!');
                
                // Find and update the player team
                const playerTeam = gameState.teams.find(team => !team.isAI);
                console.log('🎯 Found player team:', playerTeam);
                
                if (playerTeam) {
                    // Ensure player team has correct completion data
                    playerTeam.score = Math.max(playerTeam.score, 7); // Ensure it's 7
                    playerTeam.completedSeals = [...gameState.completedSeals];
                    playerTeam.lastSealTime = Date.now();
                    console.log('✅ Updated player team:', playerTeam);
                }
                
                // End the game and show winner modal
                console.log('🎉 Calling handleAIGameEnd for player victory');
                handleAIGameEnd(playerTeam || { name: gameState.currentTeam, isAI: false }, elapsed);
                
            } else if (gameState.roomCode) {
                // Multiplayer mode - winner detection handled in Firebase update
                console.log('🏆 Multiplayer mode - winner detection handled in Firebase update');
            } else {
                // Single player mode - show proper completion screen
                console.log('🎮 Single player mode - showing completion screen');
                gameState.isGameActive = false;
                
                // Show completion modal with proper victory screen
                const completionModal = `
                    <div id="completionModal" style="
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                        background: rgba(0,0,0,0.9); display: flex; justify-content: center; 
                        align-items: center; z-index: 10000;">
                        <div style="
                            background: linear-gradient(145deg, #2c1810, #3a1f12);
                            border: 3px solid #ffd700; border-radius: 15px; padding: 40px;
                            text-align: center; max-width: 600px; width: 95%;
                            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.3);">
                            <h2 style="color: #ffd700; font-size: 2.5em; margin-bottom: 20px; 
                                       text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">🏆 VICTORY! 🏆</h2>
                            <div style="margin: 20px 0;">
                                <div style="font-size: 1.4em; color: #c9a96e; margin-bottom: 15px; font-weight: bold;">
                                    🎉 Congratulations! All Seven Seals Unlocked! 🎉
                                </div>
                                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #c9a96e; 
                                            border-radius: 8px; padding: 15px; margin: 15px 0;">
                                    <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Team:</strong> ${gameState.currentTeam}</p>
                                    <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Completion Time:</strong> ${minutes}:${seconds.toString().padStart(2, '0')}</p>
                                    <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Seals Completed:</strong> 7/7</p>
                                </div>
                                <div style="font-size: 1.1em; color: #b8a082; line-height: 1.5; margin: 20px 0;">
                                    You have successfully unlocked all the mysteries of the Seven Seals!<br>
                                    The ancient wisdom is now yours to keep.
                                </div>
                            </div>
                            <div style="margin-top: 30px;">
                                <button onclick="closeCompletionModal(); goBack();" style="
                                    background: #d4af37; color: #2c1810; border: none; padding: 12px 24px;
                                    border-radius: 5px; font-size: 1.1em; cursor: pointer; font-weight: bold; margin: 0 10px;">
                                    🎮 Play Again
                                </button>
                                <button onclick="closeCompletionModal();" style="
                                    background: #6b4d37; color: #f4f1e8; border: none; padding: 12px 24px;
                                    border-radius: 5px; font-size: 1.1em; cursor: pointer; font-weight: bold; margin: 0 10px;">
                                    ⚡ Continue
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', completionModal);
                
                // Auto-close after 60 seconds
                setTimeout(() => {
                    closeCompletionModal();
                }, 60000);
            }
        }

        // Close completion modal
        function closeCompletionModal() {
            const modal = document.getElementById('completionModal');
            if (modal) {
                modal.remove();
            }
        }

        // Enhanced winner detection and ranking system for multi-team scenarios
        async function checkForGameWinner(completionTime) {
            try {
                console.log('🏆 checkForGameWinner() called with time:', completionTime);
                console.log('📡 Database available?', !!database);
                console.log('🎮 Room code:', gameState.roomCode);
                
                if (!database || !gameState.roomCode) {
                    console.log('❌ Missing database or room code, returning');
                    return;
                }

                console.log('🏆 Checking for game winner...');
                
                // Mark this team as completed with timestamp and last seal time
                const teamCompletionData = {
                    completed: true,
                    completionTime: completionTime,
                    completedAt: firebase.database.ServerValue.TIMESTAMP,
                    finalScore: gameState.completedSeals.length,
                    lastSealTime: Date.now() // Track when last seal was clicked for tiebreaking
                };

                console.log('💾 Updating team data:', teamCompletionData);
                console.log('📍 Path:', `rooms/${gameState.roomCode}/teams/${gameState.currentTeam}`);
                
                await database.ref(`rooms/${gameState.roomCode}/teams/${gameState.currentTeam}`).update(teamCompletionData);
                console.log('✅ Team data updated successfully');

                // Check if this is the first team to complete
                console.log('🔍 Checking room data for other completed teams...');
                const roomSnapshot = await database.ref(`rooms/${gameState.roomCode}`).once('value');
                const roomData = roomSnapshot.val();
                
                console.log('📊 Current room data:', roomData);

                if (roomData && roomData.teams) {
                    // Check for teams that completed 7 seals
                    const teams = Object.values(roomData.teams);
                    const teamsWithSevenSeals = teams.filter(team => {
                        const sealsCount = team.completedSeals ? team.completedSeals.length : (team.score || 0);
                        return sealsCount >= 7 || team.completed;
                    });
                    
                    console.log('👥 All teams scores:', teams.map(t => ({ 
                        name: t.name, 
                        seals: t.completedSeals ? t.completedSeals.length : (t.score || 0),
                        completed: t.completed 
                    })));
                    console.log('🏁 Teams with 7 seals:', teamsWithSevenSeals.length);

                    if (teamsWithSevenSeals.length === 1) {
                        // This is the winner! End the game for everyone
                        console.log('🏆 First team to complete - declaring winner!');
                        
                        // Calculate final rankings for all teams
                        const finalRankings = await calculateFinalRankings(teams);
                        
                        const gameEndData = {
                            winner: gameState.currentTeam,
                            completionTime: completionTime,
                            endedAt: firebase.database.ServerValue.TIMESTAMP,
                            gameActive: false,
                            status: 'finished',
                            finalRankings: finalRankings
                        };

                        console.log('💾 Setting game end data:', gameEndData);
                        await database.ref(`rooms/${gameState.roomCode}`).update(gameEndData);
                        console.log('✅ Game end data saved to Firebase');
                        
                        // Show winner modal with rankings to all players
                        console.log('🎉 Showing winner modal with rankings...');
                        showWinnerModalWithRankings(gameState.currentTeam, completionTime, finalRankings, true);
                    } else if (teamsWithSevenSeals.length > 1) {
                        // Someone else already won - show existing rankings if available
                        console.log('🥈 Another team already won');
                        if (roomData.finalRankings) {
                            showWinnerModalWithRankings(roomData.winner, roomData.completionTime, roomData.finalRankings, false);
                        } else {
                            const winner = teamsWithSevenSeals[0];
                            showWinnerModal(winner.name || 'Another team', winner.completionTime || completionTime, false);
                        }
                    } else {
                        console.log('🔄 No teams with 7 seals yet');
                    }
                } else {
                    console.log('❌ No room data or teams found');
                }

            } catch (error) {
                console.error('Error checking for winner:', error);
                const minutes = Math.floor(completionTime / 60000);
                const seconds = Math.floor((completionTime % 60000) / 1000);
                showAlert(`🎉 Congratulations! All seals opened in ${minutes}:${seconds.toString().padStart(2, '0')}!`, 'success');
            }
        }

        // Calculate final rankings for all teams
        async function calculateFinalRankings(teams) {
            console.log('📊 Calculating final rankings for teams:', teams.length);
            
            const rankings = teams.map(team => {
                const sealsCount = team.completedSeals ? team.completedSeals.length : (team.score || 0);
                return {
                    teamName: team.name,
                    sealsCompleted: sealsCount,
                    completionTime: team.completionTime || null,
                    lastSealTime: team.lastSealTime || Date.now(),
                    completed: team.completed || false
                };
            });

            // Sort rankings:
            // 1. By completion status (completed teams first)
            // 2. By number of seals completed (higher is better)
            // 3. By completion time for completed teams (faster is better)
            // 4. By last seal time for incomplete teams (faster last seal is better)
            rankings.sort((a, b) => {
                // Completed teams come first
                if (a.completed && !b.completed) return -1;
                if (!a.completed && b.completed) return 1;
                
                // Both completed or both incomplete - sort by seals
                if (a.sealsCompleted !== b.sealsCompleted) {
                    return b.sealsCompleted - a.sealsCompleted; // Higher seals first
                }
                
                // Same number of seals - use time
                if (a.completed && b.completed && a.completionTime && b.completionTime) {
                    return a.completionTime - b.completionTime; // Faster completion first
                }
                
                // For incomplete teams with same seals, use last seal time
                if (a.lastSealTime && b.lastSealTime) {
                    return a.lastSealTime - b.lastSealTime; // Earlier last seal first
                }
                
                return 0;
            });

            // Add rank positions
            rankings.forEach((team, index) => {
                team.rank = index + 1;
            });

            console.log('🏆 Final rankings calculated:', rankings);
            return rankings;
        }

        // Enhanced winner modal with final rankings for multi-team scenarios
        function showWinnerModalWithRankings(winnerTeam, completionTime, rankings, isWinner) {
            console.log('🎉 showWinnerModalWithRankings() called');
            console.log('🏆 Winner team:', winnerTeam);
            console.log('⏰ Completion time:', completionTime);
            console.log('📊 Rankings:', rankings);
            console.log('🎯 Is winner?', isWinner);
            
            const minutes = Math.floor(completionTime / 60000);
            const seconds = Math.floor((completionTime % 60000) / 1000);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const modalTitle = isWinner ? '🏆 CONGRATULATIONS!' : '🎮 GAME OVER';
            const modalMessage = isWinner ? 
                `YOUR TEAM HAS WON THE GAME!` : 
                `${winnerTeam} HAS WON THE GAME!`;

            // Generate rankings HTML
            let rankingsHTML = '';
            if (rankings && rankings.length > 0) {
                rankingsHTML = `
                    <div style="background: rgba(0, 0, 0, 0.4); border: 1px solid #c9a96e; 
                                border-radius: 8px; padding: 15px; margin: 15px 0; max-height: 250px; overflow-y: auto;">
                        <h3 style="color: #ffd700; margin-bottom: 15px; text-align: center;">🏅 Final Rankings</h3>
                        <div style="text-align: left;">
                `;
                
                rankings.forEach((team, index) => {
                    const rank = team.rank || (index + 1);
                    const isCurrentTeam = team.teamName === gameState.currentTeam;
                    const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                    const completionDisplay = team.completed ? 
                        `✅ ${Math.floor((team.completionTime || 0) / 60000)}:${Math.floor(((team.completionTime || 0) % 60000) / 1000).toString().padStart(2, '0')}` : 
                        `⏱️ ${team.sealsCompleted}/7 seals`;
                    const teamLabel = isCurrentTeam ? ' (YOU)' : (team.isAI ? ' 🤖' : '');
                    
                    rankingsHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; 
                                    padding: 8px 12px; margin: 5px 0; background: rgba(0, 0, 0, 0.2); 
                                    border-radius: 5px; ${isCurrentTeam ? 'border: 1px solid #ffd700;' : ''}">
                            <span style="color: #ffd700; font-weight: bold; min-width: 30px;">${medal}</span>
                            <span style="color: ${isCurrentTeam ? '#ffd700' : '#e8dcc0'}; flex: 1; margin: 0 10px; font-weight: ${isCurrentTeam ? 'bold' : 'normal'};">
                                ${team.teamName}${teamLabel}
                            </span>
                            <span style="color: #c9a96e; font-size: 0.9em;">${completionDisplay}</span>
                        </div>
                    `;
                });
                
                rankingsHTML += `
                        </div>
                    </div>
                `;
            }
                
            console.log('🎨 Creating enhanced modal with rankings');

            const modalHTML = `
                <div id="winnerModal" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); display: flex; justify-content: center; 
                    align-items: center; z-index: 10000;">
                    <div style="
                        background: linear-gradient(145deg, #2c1810, #3a1f12);
                        border: 3px solid #ffd700; border-radius: 15px; padding: 30px;
                        text-align: center; max-width: 600px; width: 95%; max-height: 90%; overflow-y: auto;
                        box-shadow: 0 8px 30px rgba(255, 215, 0, 0.3);">
                        <h2 style="color: #ffd700; font-size: 2.5em; margin-bottom: 20px; 
                                   text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">${modalTitle}</h2>
                        <div style="margin: 20px 0;">
                            <div style="font-size: 1.4em; color: #c9a96e; margin-bottom: 15px; font-weight: bold;">
                                ${modalMessage}
                            </div>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #c9a96e; 
                                        border-radius: 8px; padding: 15px; margin: 15px 0;">
                                <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Winning Team:</strong> ${winnerTeam}</p>
                                <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Completion Time:</strong> ${timeString}</p>
                            </div>
                            ${rankingsHTML}
                        </div>
                        <button onclick="closeWinnerModal()" style="
                            background: #d4af37; color: #2c1810; border: none; padding: 12px 24px;
                            border-radius: 5px; font-size: 1.1em; cursor: pointer; font-weight: bold;">
                            Return to Lobby
                        </button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Lock the game for all players
            lockGameInputs();

            // Auto-close after 45 seconds (more time to view rankings)
            setTimeout(() => {
                closeWinnerModal();
            }, 45000);
        }

        // Show winner modal to all players (legacy function for backward compatibility)
        function showWinnerModal(winnerTeam, completionTime, isWinner) {
            console.log('🎉 showWinnerModal() called');
            console.log('🏆 Winner team:', winnerTeam);
            console.log('⏰ Completion time:', completionTime);
            console.log('🎯 Is winner?', isWinner);
            
            const minutes = Math.floor(completionTime / 60000);
            const seconds = Math.floor((completionTime % 60000) / 1000);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const modalTitle = isWinner ? '🏆 CONGRATULATIONS!' : '🎮 GAME OVER';
            const modalMessage = isWinner ? 
                `Your team has won the game!` : 
                `${winnerTeam} has won the game!`;
                
            console.log('🎨 Creating modal with title:', modalTitle);

            const modalHTML = `
                <div id="winnerModal" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); display: flex; justify-content: center; 
                    align-items: center; z-index: 10000;">
                    <div style="
                        background: linear-gradient(145deg, #2c1810, #3a1f12);
                        border: 3px solid #ffd700; border-radius: 15px; padding: 30px;
                        text-align: center; max-width: 500px; width: 90%;
                        box-shadow: 0 8px 30px rgba(255, 215, 0, 0.3);">
                        <h2 style="color: #ffd700; font-size: 2.5em; margin-bottom: 20px; 
                                   text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">${modalTitle}</h2>
                        <div style="margin: 20px 0;">
                            <div style="font-size: 1.4em; color: #c9a96e; margin-bottom: 15px; font-weight: bold;">
                                ${modalMessage}
                            </div>
                            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid #c9a96e; 
                                        border-radius: 8px; padding: 15px; margin: 15px 0;">
                                <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Winning Team:</strong> ${winnerTeam}</p>
                                <p style="margin: 8px 0; color: #e8dcc0;"><strong style="color: #ffd700;">Completion Time:</strong> ${timeString}</p>
                            </div>
                        </div>
                        <button onclick="closeWinnerModal()" style="
                            background: #d4af37; color: #2c1810; border: none; padding: 12px 24px;
                            border-radius: 5px; font-size: 1.1em; cursor: pointer; font-weight: bold;">
                            Return to Lobby
                        </button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Lock the game for all players
            lockGameInputs();

            // Auto-close after 30 seconds
            setTimeout(() => {
                closeWinnerModal();
            }, 30000);
        }

        // Lock game inputs when game ends
        function lockGameInputs() {
            gameState.isGameActive = false;
            
            // Disable all seal buttons
            const sealButtons = document.querySelectorAll('.seal');
            sealButtons.forEach(button => {
                button.onclick = null;
                button.style.pointerEvents = 'none';
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });

            // Close any open puzzle modals
            const puzzleModal = document.getElementById('puzzleModal');
            if (puzzleModal) {
                puzzleModal.style.display = 'none';
            }

            // Add visual indicator that game has ended
            const gameContainer = document.getElementById('gameContainer');
            if (gameContainer) {
                gameContainer.style.filter = 'grayscale(30%)';
                
                // Add overlay message
                const overlay = document.createElement('div');
                overlay.id = 'gameEndOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.3);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 5000;
                    pointer-events: none;
                `;
                overlay.innerHTML = `
                    <div style="
                        background: rgba(139, 0, 0, 0.9);
                        color: #ffd700;
                        padding: 20px 40px;
                        border-radius: 10px;
                        border: 2px solid #ffd700;
                        font-size: 1.5em;
                        font-weight: bold;
                        text-align: center;
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                    ">
                        🔒 GAME ENDED
                        <br>
                        <span style="font-size: 0.7em; margin-top: 10px; display: block;">
                            A team has completed all seven seals
                        </span>
                    </div>
                `;
                document.body.appendChild(overlay);
            }

            console.log('🔒 Game inputs locked - game has ended');
        }

        // Close winner modal
        function closeWinnerModal() {
            const modal = document.getElementById('winnerModal');
            if (modal) {
                modal.remove();
            }
            
            // Clean up game end overlay
            const overlay = document.getElementById('gameEndOverlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Reset game container filter
            const gameContainer = document.getElementById('gameContainer');
            if (gameContainer) {
                gameContainer.style.filter = '';
            }
            
            // Go back to lobby
            showLobby();
        }

        function resetGameState() {
            // Generate new random questions for replayability
            if (gameOptions.randomMode) {
                window.PuzzleManager.regeneratePuzzles();
            }
            
            gameState.completedSeals = [];
            gameState.isGameActive = false;
            gameState.startTime = null;

            // Reset team scores
            gameState.teams.forEach(team => {
                team.score = 0;
                team.completedSeals = [];
            });

            renderSeals();
            updateProgress();
            updateLeaderboard();

            document.getElementById('timer').textContent = '00:00';
            showAlert('Game reset! Fresh challenges await!', 'success');
        }

        function goBack() {
            // Clean up Firebase listeners
            if (gameState.roomRef) {
                gameState.roomRef.off();
                gameState.roomRef = null;
            }

            // Clean up AI timers
            if (gameState.aiTimers) {
                gameState.aiTimers.forEach(timer => clearTimeout(timer));
                gameState.aiTimers = [];
            }

            // Hide all game sections
            document.getElementById('multiplayerSetup').style.display = 'none';
            document.getElementById('aiSetup').style.display = 'none';
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none';

            // Show mode selection
            document.getElementById('modeSelection').style.display = 'grid';

            // Reset game state
            gameState = {
                mode: '',
                currentTeam: '',
                teams: [],
                completedSeals: [],
                startTime: null,
                currentPuzzle: null,
                isGameActive: false,
                roomCode: '',
                isHost: false,
                roomRef: null,
                // AI Mode specific
                aiTeams: [],
                aiTimers: [],
                aiDifficulty: 'medium'
            };

            // Clear URL parameters
            window.history.pushState({}, '', window.location.pathname);
        }

        function copyRoomLink() {
            const shareLink = document.getElementById('shareLink').textContent;

            if (navigator.clipboard) {
                navigator.clipboard.writeText(shareLink).then(() => {
                    showAlert('Room link copied to clipboard!', 'success');
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = shareLink;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showAlert('Room link copied to clipboard!', 'success');
            }
        }

        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.textContent = message;

            document.body.appendChild(alert);

            setTimeout(() => alert.classList.add('show'), 100);

            setTimeout(() => {
                alert.classList.remove('show');
                setTimeout(() => document.body.removeChild(alert), 300);
            }, 3000);
        }

        // Universal Game Options - Available in all modes
        let gameOptions = {
            hintsEnabled: false,
            randomMode: true,
            detailedProgress: true
        };

        // Complexity system
        let gameComplexity = {
            level: 'intermediate',
            selectedMode: null,
            settings: {
                beginner: {
                    hintsAvailable: true,
                    answerTolerance: 'high',
                    timeMultiplier: 1.5,
                    puzzleComplexity: 'simple',
                    encouragement: true
                },
                intermediate: {
                    hintsAvailable: true,
                    answerTolerance: 'medium',
                    timeMultiplier: 1.0,
                    puzzleComplexity: 'mixed',
                    encouragement: false
                },
                advanced: {
                    hintsAvailable: false,
                    answerTolerance: 'low',
                    timeMultiplier: 0.8,
                    puzzleComplexity: 'complex',
                    encouragement: false
                },
                expert: {
                    hintsAvailable: false,
                    answerTolerance: 'strict',
                    timeMultiplier: 0.6,
                    puzzleComplexity: 'maximum',
                    encouragement: false
                }
            }
        };

        // Load saved game options from localStorage
        function loadGameOptions() {
            try {
                const saved = localStorage.getItem('scrollGameOptions');
                if (saved) {
                    gameOptions = { ...gameOptions, ...JSON.parse(saved) };
                }
            } catch (error) {
                console.log('Using default game options');
            }
            
            // Update UI toggles
            document.getElementById('hintsEnabled').checked = gameOptions.hintsEnabled;
            document.getElementById('randomMode').checked = gameOptions.randomMode;
            document.getElementById('detailedProgress').checked = gameOptions.detailedProgress;
        }

        // Save game options to localStorage
        function saveGameOptions() {
            localStorage.setItem('scrollGameOptions', JSON.stringify(gameOptions));
        }

        // Toggle sound functionality
        function toggleSound() {
            if (window.ImmersionEngine && window.ImmersionEngine.toggleSound) {
                const isEnabled = window.ImmersionEngine.toggleSound();
                document.getElementById('soundEnabled').checked = isEnabled;
                
                if (isEnabled) {
                    showAlert('🔊 Sound effects enabled', 'success');
                    // Play a test sound
                    window.ImmersionEngine.playSound('sealActivation');
                } else {
                    showAlert('🔇 Sound effects disabled', 'info');
                }
            } else {
                showAlert('🔇 Sound system not available', 'error');
                console.warn('⚠️ ImmersionEngine not available for sound toggle');
            }
        }

        // Toggle hints functionality
        function toggleHints() {
            gameOptions.hintsEnabled = document.getElementById('hintsEnabled').checked;
            saveGameOptions();
            
            if (gameOptions.hintsEnabled) {
                showAlert('💡 Enhanced hints enabled - additional guidance will be shown', 'success');
            } else {
                showAlert('💡 Enhanced hints disabled - pure challenge mode', 'info');
            }
            
            // Update any existing puzzle displays
            updatePuzzleHintsDisplay();
        }

        // Toggle random mode
        function toggleRandomMode() {
            gameOptions.randomMode = document.getElementById('randomMode').checked;
            saveGameOptions();
            
            if (gameOptions.randomMode) {
                showAlert('🔀 Random mode enabled - fresh puzzles each game!', 'success');
                // Regenerate puzzles for current game if already started
                if (gameState.isGameActive) {
                    window.PuzzleManager.regeneratePuzzles();
                }
            } else {
                showAlert('🔀 Random mode disabled - consistent puzzles', 'info');
            }
        }

        // Toggle detailed progress
        function toggleDetailedProgress() {
            gameOptions.detailedProgress = document.getElementById('detailedProgress').checked;
            saveGameOptions();
            
            if (gameOptions.detailedProgress) {
                showAlert('📊 Detailed progress enabled', 'success');
            } else {
                showAlert('📊 Detailed progress disabled', 'info');
            }
            
            updateProgressDisplay();
        }

        // Update puzzle hints display based on settings
        function updatePuzzleHintsDisplay() {
            const hintElements = document.querySelectorAll('.cipher-hint, .puzzle-hint, .challenge-hint');
            hintElements.forEach(hint => {
                hint.style.display = gameOptions.hintsEnabled ? 'block' : 'none';
            });
        }

        // Update progress display based on settings
        function updateProgressDisplay() {
            const progressText = document.getElementById('progressText');
            if (progressText && gameOptions.detailedProgress) {
                const completed = gameState.completedSeals.length;
                const elapsed = gameState.startTime ? Date.now() - gameState.startTime : 0;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                progressText.textContent = `${completed}/7 Seals (${minutes}:${seconds.toString().padStart(2, '0')})`;
            } else if (progressText) {
                progressText.textContent = `${gameState.completedSeals.length}/7 Seals`;
            }
        }

        // Initialize game options when game starts
        function initializeGameOptions() {
            loadGameOptions();
            
            // Initialize sound toggle
            if (window.ImmersionEngine) {
                document.getElementById('soundEnabled').checked = window.ImmersionEngine.soundEnabled;
            }
            
            // Apply random mode setting
            if (gameOptions.randomMode) {
                window.PuzzleManager.regeneratePuzzles();
            }
        }

        // Handle Enter key in inputs
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (e.target.id === 'puzzleAnswer') {
                    submitAnswer();
                }
            }
        });

        // Complexity Selection Functions
        function showComplexityModal(gameMode) {
            gameComplexity.selectedMode = gameMode;
            document.getElementById('complexityModal').style.display = 'flex';
            
            // Load saved complexity level
            const saved = localStorage.getItem('scrollComplexityLevel');
            if (saved) {
                gameComplexity.level = saved;
                selectComplexity(saved, false);
            }
        }

        function closeComplexityModal() {
            document.getElementById('complexityModal').style.display = 'none';
            gameComplexity.selectedMode = null;
            
            // Reset selection
            document.querySelectorAll('.complexity-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('confirmComplexity').disabled = true;
        }

        function selectComplexity(level, showFeedback = true) {
            gameComplexity.level = level;
            
            // Update UI
            document.querySelectorAll('.complexity-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            const selectedCard = document.querySelector(`[data-complexity="${level}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            document.getElementById('confirmComplexity').disabled = false;
            
            if (showFeedback) {
                const complexityNames = {
                    beginner: 'Beginner - Guided Journey',
                    intermediate: 'Intermediate - Balanced Challenge', 
                    advanced: 'Advanced - Scholar\'s Trial',
                    expert: 'Expert - Master\'s Crucible'
                };
                
                showAlert(`🎯 Selected: ${complexityNames[level]}`, 'info');
            }
            
            // Save preference
            localStorage.setItem('scrollComplexityLevel', level);
        }

        function confirmComplexitySelection() {
            const mode = gameComplexity.selectedMode;
            const level = gameComplexity.level;
            
            if (!mode || !level) return;
            
            // Apply complexity settings
            applyComplexitySettings(level);
            
            closeComplexityModal();
            
            // Start the appropriate game mode
            switch(mode) {
                case 'single':
                    startSinglePlayer();
                    break;
                case 'ai':
                    startAIMode();
                    break;
                case 'multiplayer':
                    showMultiplayerChoice();
                    break;
                default:
                    console.error('Unknown game mode:', mode);
            }
        }

        function applyComplexitySettings(level) {
            const settings = gameComplexity.settings[level];
            
            // Apply settings to game options
            gameOptions.hintsEnabled = settings.hintsAvailable;
            document.getElementById('hintsEnabled').checked = settings.hintsAvailable;
            
            // Store complexity-specific settings
            gameState.complexity = {
                level: level,
                settings: settings
            };
            
            console.log(`🎯 Applied ${level} complexity settings:`, settings);
            showAlert(`⚔️ Challenge Level: ${level.toUpperCase()} - Settings Applied!`, 'success');
        }

        // Modify existing mode selection functions to show complexity modal first
        function selectMode(mode) {
            console.log('Mode selected:', mode);
            
            // Show complexity selection before starting any mode
            showComplexityModal(mode);
        }

        // Original game start functions (now called after complexity selection)
        function startSinglePlayer() {
            console.log('🎮 Starting Single Player with complexity:', gameComplexity.level);
            
            // Hide mode selection and show setup if needed
            document.getElementById('modeSelection').style.display = 'none';
            
            // Start game immediately for single player (no additional setup needed)
            initializeSinglePlayerGame();
        }

        function startAIMode() {
            console.log('🤖 Starting AI Mode with complexity:', gameComplexity.level);
            
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('aiSetup').style.display = 'block';
        }

        function showMultiplayerChoice() {
            console.log('🌐 Starting Multiplayer with complexity:', gameComplexity.level);
            
            // Show choice modal for create vs join
            const choiceModal = `
                <div id="multiplayerChoiceModal" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); display: flex; justify-content: center; 
                    align-items: center; z-index: 1002;">
                    <div style="
                        background: linear-gradient(135deg, #2c1810, #4a3425);
                        border: 3px solid #d4af37; border-radius: 15px; padding: 40px;
                        text-align: center; max-width: 500px; width: 95%;">
                        <h2 style="color: #d4af37; font-size: 2em; margin-bottom: 30px;">🌐 Multiplayer Mode</h2>
                        <p style="color: #b8a082; margin-bottom: 30px; font-size: 1.1em;">
                            Would you like to create a new room or join an existing one?
                        </p>
                        <div style="display: flex; gap: 20px; justify-content: center;">
                            <button onclick="createMultiplayerRoom()" style="
                                background: #d4af37; color: #2c1810; border: none; padding: 15px 25px;
                                border-radius: 8px; font-size: 1.1em; cursor: pointer; font-weight: bold;">
                                🏠 Create Room
                            </button>
                            <button onclick="joinMultiplayerRoom()" style="
                                background: #6b4d37; color: #f4f1e8; border: none; padding: 15px 25px;
                                border-radius: 8px; font-size: 1.1em; cursor: pointer; font-weight: bold;">
                                🔗 Join Room
                            </button>
                        </div>
                        <button onclick="closeMultiplayerChoice()" style="
                            background: transparent; color: #b8a082; border: 1px solid #6b4d37; 
                            padding: 10px 20px; border-radius: 5px; font-size: 1em; cursor: pointer; 
                            margin-top: 20px;">
                            ← Back
                        </button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', choiceModal);
        }

        function closeMultiplayerChoice() {
            const modal = document.getElementById('multiplayerChoiceModal');
            if (modal) {
                modal.remove();
            }
        }

        function createMultiplayerRoom() {
            closeMultiplayerChoice();
            console.log('👥 Creating multiplayer room with complexity:', gameComplexity.level);
            
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('multiplayerSetup').style.display = 'block';
            
            // Show create room section
            document.getElementById('createRoom').style.display = 'block';
            document.getElementById('joinRoom').style.display = 'none';
        }

        function joinMultiplayerRoom() {
            closeMultiplayerChoice();
            console.log('🔗 Joining multiplayer room with complexity:', gameComplexity.level);
            
            document.getElementById('modeSelection').style.display = 'none';
            document.getElementById('multiplayerSetup').style.display = 'block';
            
            // Show join room section
            document.getElementById('createRoom').style.display = 'none';
            document.getElementById('joinRoom').style.display = 'block';
        }

        // Initialize single player game
        function initializeSinglePlayerGame() {
            console.log('🎮 Initializing single player game...');
            
            // Set up basic game state
            gameState.mode = 'single';
            gameState.currentTeam = `Player Team`;
            gameState.teams = [
                {
                    name: gameState.currentTeam,
                    score: 0,
                    completedSeals: [],
                    isAI: false
                }
            ];
            gameState.startTime = Date.now();
            gameState.isGameActive = true;
            
            // Apply complexity settings to puzzle generation
            if (gameOptions.randomMode) {
                window.PuzzleManager.regeneratePuzzles();
            }
            
            // Show game interface
            document.getElementById('gameContainer').style.display = 'block';
            
            renderSeals();
            updateProgress();
            updateLeaderboard();
            
            showAlert(`🎮 Single Player Mode Started! Complexity: ${gameComplexity.level.toUpperCase()}`, 'success');
        }

        // Drag and Drop Functionality
        function initializeDragAndDrop() {
            // Enable drag and drop for all drag items
            document.addEventListener('dragstart', function(e) {
                if (e.target.classList.contains('drag-item')) {
                    e.target.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', '');
                }
            });

            document.addEventListener('dragend', function(e) {
                if (e.target.classList.contains('drag-item')) {
                    e.target.classList.remove('dragging');
                }
            });

            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (e.target.classList.contains('drop-zone') || e.target.closest('.drop-zone')) {
                    const dropZone = e.target.classList.contains('drop-zone') ? e.target : e.target.closest('.drop-zone');
                    dropZone.classList.add('drag-over');
                }
            });

            document.addEventListener('dragleave', function(e) {
                if (e.target.classList.contains('drop-zone')) {
                    e.target.classList.remove('drag-over');
                }
            });

            document.addEventListener('drop', function(e) {
                e.preventDefault();
                const dropZone = e.target.classList.contains('drop-zone') ? e.target : e.target.closest('.drop-zone');
                
                if (dropZone) {
                    dropZone.classList.remove('drag-over');
                    const draggedItem = document.querySelector('.dragging');
                    
                    if (draggedItem) {
                        // For chronological order - only allow one item per drop zone
                        if (dropZone.hasAttribute('data-position')) {
                            // Remove any existing item from this drop zone
                            const existingItem = dropZone.querySelector('.drag-item');
                            if (existingItem) {
                                // Move existing item back to pool
                                const pool = document.querySelector('.items-pool');
                                if (pool) {
                                    pool.appendChild(existingItem);
                                }
                            }
                            
                            // Add the dragged item to this drop zone
                            dropZone.appendChild(draggedItem);
                            dropZone.classList.add('filled');
                            updateDropZoneText(dropZone);
                        }
                        // For scripture topics - allow multiple items per topic
                        else if (dropZone.hasAttribute('data-topic')) {
                            dropZone.appendChild(draggedItem);
                            dropZone.classList.add('filled');
                            updateTopicDropZoneText(dropZone);
                        }
                    }
                }
            });
        }

        function updateDropZoneText(dropZone) {
            const draggedItem = dropZone.querySelector('.drag-item');
            if (draggedItem) {
                const position = dropZone.getAttribute('data-position');
                dropZone.innerHTML = '';
                dropZone.appendChild(draggedItem);
            } else {
                const position = dropZone.getAttribute('data-position');
                dropZone.innerHTML = `Drop event ${parseInt(position) + 1} here`;
                dropZone.classList.remove('filled');
            }
        }

        function updateTopicDropZoneText(dropZone) {
            const items = dropZone.querySelectorAll('.drag-item');
            if (items.length === 0) {
                const topicName = dropZone.getAttribute('data-topic');
                dropZone.innerHTML = `Drop ${topicName.toLowerCase()} verses here`;
                dropZone.classList.remove('filled');
            }
        }

        // Enhanced seal opening with immersive effects
        async function openSeal(sealId) {
            const seal = window.GameData.seals.find(s => s.id === sealId);
            if (!seal) return;

            // Check if game is still active
            if (!gameState.isGameActive) {
                showAlert('Game has ended. No more seals can be opened!', 'error');
                return;
            }
            
            if (gameState.completedSeals.includes(seal.id)) {
                showAlert('This seal is already opened!', 'error');
                return;
            }

            // Check if required seals are completed
            if (seal.requiredSeals && seal.requiredSeals.length > 0) {
                const missingSeals = seal.requiredSeals.filter(reqId => !gameState.completedSeals.includes(reqId));
                if (missingSeals.length > 0) {
                    showAlert(`Complete seals ${missingSeals.join(', ')} first!`, 'error');
                    return;
                }
            }
            
            // Find the seal element for visual effects (fix selector to work with onclick function)
            const sealElement = document.querySelector(`[data-seal-id="${sealId}"]`) || 
                               document.querySelector(`.seal:nth-child(${sealId})`);
            
            // Trigger immersive seal activation
            if (window.ImmersionEngine && sealElement) {
                await window.ImmersionEngine.triggerSealActivation(sealElement, sealId);
            }
            
            gameState.currentPuzzle = seal;
            
            // Enhanced title with immersive elements
            document.getElementById('puzzleTitle').innerHTML = `
                <span class="seal-activation-title">
                    <span class="seal-number-display">${seal.id}</span>
                    ${seal.title}
                </span>
            `;
            
            // Generate puzzle content (now with potential AI generation)
            const puzzleContent = await window.PuzzleManager.generatePuzzleContent(seal.id, seal.puzzle);
            document.getElementById('puzzleQuestion').innerHTML = puzzleContent;
            
            // Show modal with enhanced appearance
            const modal = document.getElementById('puzzleModal');
            modal.style.display = 'block';
            
            // Apply immersive modal effects
            if (window.ImmersionEngine) {
                window.ImmersionEngine.enhanceModalAppearance(modal, seal.puzzle);
            }
            
            // Initialize drag and drop for new content
            setTimeout(() => {
                initializeDragAndDrop();
                
                // Enhance drag and drop with visual effects
                if (window.ImmersionEngine) {
                    window.ImmersionEngine.enhanceDragAndDrop();
                }
            }, 100);
        }

        // Initialize game engines
        function initializeGameEngines() {
            try {
                // Initialize AI Engine
                if (typeof BibleGameAI !== 'undefined') {
                    window.BibleGameAI = new BibleGameAI();
                    console.log('✅ Bible Game AI initialized');
                } else {
                    console.warn('⚠️ BibleGameAI class not found');
                }

                // Initialize Immersion Engine
                if (typeof ImmersionEngine !== 'undefined') {
                    window.ImmersionEngine = new ImmersionEngine();
                    console.log('✅ Immersion Engine initialized');
                } else {
                    console.warn('⚠️ ImmersionEngine class not found');
                }
            } catch (error) {
                console.error('❌ Error initializing game engines:', error);
            }
        }

        // Spiritual Content Management
        const spiritualContent = {
            scriptureMotivations: [
                {
                    text: "Study to show yourself approved unto God, a workman that needs not to be ashamed, rightly dividing the word of truth.",
                    reference: "2 Timothy 2:15"
                },
                {
                    text: "Your word is a lamp unto my feet, and a light unto my path.",
                    reference: "Psalm 119:105"
                },
                {
                    text: "Faith comes by hearing, and hearing by the word of God.",
                    reference: "Romans 10:17"
                },
                {
                    text: "All Scripture is given by inspiration of God, and is profitable for doctrine, for reproof, for correction, for instruction in righteousness.",
                    reference: "2 Timothy 3:16"
                },
                {
                    text: "The entrance of Your words gives light; it gives understanding to the simple.",
                    reference: "Psalm 119:130"
                },
                {
                    text: "Heaven and earth will pass away, but My words will by no means pass away.",
                    reference: "Matthew 24:35"
                },
                {
                    text: "Blessed is the man who walks not in the counsel of the ungodly, but his delight is in the law of the Lord.",
                    reference: "Psalm 1:1-2"
                },
                {
                    text: "The fear of the Lord is the beginning of wisdom, and the knowledge of the Holy One is understanding.",
                    reference: "Proverbs 9:10"
                }
            ],
            ministerialWisdom: [
                {
                    text: "The Word of God is the foundation of all true spiritual knowledge and victory in life.",
                    attribution: "Biblical Teaching on Faith"
                },
                {
                    text: "When we meditate on God's Word day and night, we become like trees planted by rivers of water.",
                    attribution: "Wisdom on Scripture Meditation"
                },
                {
                    text: "Divine wisdom is not learned in classrooms but revealed through intimate fellowship with the Holy Spirit.",
                    attribution: "Understanding Spiritual Revelation"
                },
                {
                    text: "Every believer is called to be a student of the Word, rightly dividing truth with precision and power.",
                    attribution: "The Call to Biblical Excellence"
                },
                {
                    text: "God's Word contains everything needed for life and godliness - study it with passion and purpose.",
                    attribution: "The Sufficiency of Scripture"
                },
                {
                    text: "The anointing upon your life increases as you increase in the knowledge of God's Word.",
                    attribution: "Growing in Spiritual Authority"
                },
                {
                    text: "Biblical wisdom transforms minds, renews hearts, and empowers believers to walk in divine purpose.",
                    attribution: "The Transforming Power of Truth"
                },
                {
                    text: "Understanding God's Word is not just academic pursuit - it's the pathway to experiencing His glory.",
                    attribution: "Living in Divine Glory"
                }
            ],
            worshipInstrumentals: [
                'Peaceful Worship Ambience',
                'Holy Spirit Instrumental',
                'Sacred Meditation Music',
                'Reverent Praise Atmosphere',
                'Gentle Worship Sounds',
                'Spiritual Reflection Music',
                'Divine Presence Instrumental',
                'Sanctuary Worship Ambience'
            ]
        };

        let currentWorshipIndex = 0;
        let worshipPlaying = false;

        function updateSpiritualContent() {
            // Update Scripture motivation
            const scriptureIndex = Math.floor(Math.random() * spiritualContent.scriptureMotivations.length);
            const scripture = spiritualContent.scriptureMotivations[scriptureIndex];
            document.getElementById('scriptureText').textContent = scripture.text;
            document.getElementById('scriptureReference').textContent = `- ${scripture.reference}`;

            // Update ministerial wisdom
            const wisdomIndex = Math.floor(Math.random() * spiritualContent.ministerialWisdom.length);
            const wisdom = spiritualContent.ministerialWisdom[wisdomIndex];
            document.getElementById('wisdomText').textContent = wisdom.text;
            document.getElementById('wisdomAttribution').textContent = `- ${wisdom.attribution}`;

            console.log('✝️ Spiritual content updated for fresh inspiration');
        }

        // Enhanced Audio System for Beautiful Worship Atmosphere
        let audioContext = null;
        let worshipAudio = null;
        let isAudioInitialized = false;
        let currentTrackIndex = 0;

        const worshipTracks = [
            {
                name: "Heavenly Peace",
                frequencies: [261.63, 329.63, 392.00, 523.25], // C major chord with octave
                modulation: { rate: 0.3, depth: 2 },
                reverb: { roomSize: 0.8, damping: 0.3 }
            },
            {
                name: "Sacred Harmony", 
                frequencies: [220.00, 277.18, 330.00, 440.00], // A minor chord
                modulation: { rate: 0.2, depth: 1.5 },
                reverb: { roomSize: 0.7, damping: 0.4 }
            },
            {
                name: "Divine Serenity",
                frequencies: [196.00, 246.94, 293.66, 392.00], // G major chord
                modulation: { rate: 0.25, depth: 1.8 },
                reverb: { roomSize: 0.9, damping: 0.2 }
            },
            {
                name: "Eternal Rest",
                frequencies: [174.61, 220.00, 261.63, 349.23], // F major chord
                modulation: { rate: 0.15, depth: 1.2 },
                reverb: { roomSize: 0.85, damping: 0.35 }
            }
        ];

        async function initializeAudio() {
            if (isAudioInitialized) return;
            
            try {
                // Initialize AudioContext with higher quality settings
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 44100,
                    latencyHint: 'playback'
                });
                
                // Create beautiful worship audio
                worshipAudio = createEnhancedWorshipAmbience();
                isAudioInitialized = true;
                console.log('🎵 Enhanced worship audio system initialized');
            } catch (error) {
                console.log('Audio initialization failed:', error);
                isAudioInitialized = true;
            }
        }

        function createEnhancedWorshipAmbience() {
            if (!audioContext) return null;
            
            const track = worshipTracks[currentTrackIndex];
            
            // Create main gain node
            const masterGain = audioContext.createGain();
            masterGain.gain.setValueAtTime(0, audioContext.currentTime);
            
            // Create reverb effect
            const convolver = audioContext.createConvolver();
            const reverbGain = audioContext.createGain();
            reverbGain.gain.setValueAtTime(track.reverb.roomSize * 0.3, audioContext.currentTime);
            
            // Create artificial reverb impulse response
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * 2; // 2 seconds reverb
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, track.reverb.damping);
                }
            }
            convolver.buffer = impulse;
            
            // Create oscillators for each frequency with modulation
            const oscillators = [];
            const gains = [];
            
            track.frequencies.forEach((freq, index) => {
                // Main oscillator
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // LFO for gentle modulation
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                
                // Set up oscillator
                osc.type = index % 2 === 0 ? 'sine' : 'triangle';
                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                
                // Set up LFO
                lfo.type = 'sine';
                lfo.frequency.setValueAtTime(track.modulation.rate, audioContext.currentTime);
                lfoGain.gain.setValueAtTime(track.modulation.depth, audioContext.currentTime);
                
                // Set up gain with gentle panning
                const panner = audioContext.createStereoPanner();
                panner.pan.setValueAtTime((index % 2 === 0 ? -0.3 : 0.3) * (index / track.frequencies.length), audioContext.currentTime);
                
                gain.gain.setValueAtTime(0.15 / track.frequencies.length, audioContext.currentTime);
                
                // Connect LFO modulation
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                
                // Connect audio chain
                osc.connect(gain);
                gain.connect(panner);
                panner.connect(masterGain);
                
                // Also send to reverb
                panner.connect(reverbGain);
                
                // Start oscillators
                osc.start();
                lfo.start();
                
                oscillators.push(osc);
                gains.push(gain);
            });
            
            // Connect reverb
            reverbGain.connect(convolver);
            convolver.connect(masterGain);
            
            // Connect to destination
            masterGain.connect(audioContext.destination);
            
            return { 
                masterGain, 
                oscillators, 
                gains, 
                convolver, 
                reverbGain,
                trackName: track.name 
            };
        }

        async function toggleWorship() {
            const button = document.getElementById('worshipToggle');
            const nowPlaying = document.getElementById('nowPlaying');
            const currentTrack = document.getElementById('currentTrack');

            // Initialize audio on first interaction (required by browsers)
            if (!isAudioInitialized) {
                await initializeAudio();
            }

            if (!worshipPlaying) {
                // Start beautiful worship atmosphere
                worshipPlaying = true;
                button.innerHTML = '<span class="worship-icon">🔇</span><span class="worship-text">Pause Worship</span>';
                button.classList.add('playing');
                nowPlaying.style.display = 'block';
                
                // Resume audio context if suspended
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Start enhanced worship audio with smooth fade-in
                if (worshipAudio && worshipAudio.masterGain) {
                    worshipAudio.masterGain.gain.setTargetAtTime(0.08, audioContext.currentTime, 2.0);
                }
                
                // Display current track name
                const trackName = worshipAudio ? worshipAudio.trackName : 'Divine Ambience';
                currentTrack.textContent = `♪ ${trackName}`;
                
                console.log('🎵 Enhanced worship atmosphere activated:', trackName);
                
                // Auto-change track every 4 minutes with smooth transitions
                if (window.worshipInterval) clearInterval(window.worshipInterval);
                window.worshipInterval = setInterval(async () => {
                    if (worshipPlaying && audioContext) {
                        // Fade out current track
                        if (worshipAudio && worshipAudio.masterGain) {
                            worshipAudio.masterGain.gain.setTargetAtTime(0, audioContext.currentTime, 1.0);
                        }
                        
                        // Wait for fade out, then change track
                        setTimeout(() => {
                            // Stop current oscillators
                            if (worshipAudio && worshipAudio.oscillators) {
                                worshipAudio.oscillators.forEach(osc => {
                                    try { osc.stop(); } catch(e) {}
                                });
                            }
                            
                            // Move to next track
                            currentTrackIndex = (currentTrackIndex + 1) % worshipTracks.length;
                            worshipAudio = createEnhancedWorshipAmbience();
                            
                            // Fade in new track
                            if (worshipAudio && worshipAudio.masterGain) {
                                worshipAudio.masterGain.gain.setTargetAtTime(0.08, audioContext.currentTime, 2.0);
                            }
                            
                            // Update display
                            const newTrackName = worshipAudio ? worshipAudio.trackName : 'Divine Ambience';
                            currentTrack.textContent = `♪ ${newTrackName}`;
                            console.log('🎵 Transitioned to:', newTrackName);
                        }, 1000);
                    }
                }, 240000); // 4 minutes
                
            } else {
                // Stop worship atmosphere with graceful fade-out
                worshipPlaying = false;
                button.innerHTML = '<span class="worship-icon">🎵</span><span class="worship-text">Gentle Worship Sounds</span>';
                button.classList.remove('playing');
                
                // Smooth fade out
                if (worshipAudio && worshipAudio.masterGain) {
                    worshipAudio.masterGain.gain.setTargetAtTime(0, audioContext.currentTime, 1.5);
                }
                
                // Hide now playing after fade completes
                setTimeout(() => {
                    nowPlaying.style.display = 'none';
                }, 1500);
                
                if (window.worshipInterval) {
                    clearInterval(window.worshipInterval);
                }
                
                console.log('🔇 Worship atmosphere gracefully faded out');
            }
        }

        // Global reset function for challenges
        function resetChallenge(challengeType) {
            if (window.PuzzleManager && window.PuzzleManager.resetChallenge) {
                window.PuzzleManager.resetChallenge(challengeType);
            } else {
                console.error('PuzzleManager not available for reset');
                location.reload(); // Fallback
            }
        }

        // Initialize options when DOM loads
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeGameEngines, 50);
            setTimeout(initializeGameOptions, 100);
            setTimeout(initializeDragAndDrop, 200);
            setTimeout(updateSpiritualContent, 300);
        });
    </script>

    <style>
        /* Enhanced Worship Controls */
        .spiritual-footer {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(138, 43, 226, 0.05));
            backdrop-filter: blur(20px);
            border-top: 2px solid rgba(255, 215, 0, 0.3);
            margin-top: 40px;
            padding: 40px 0;
            position: relative;
            box-shadow: 
                0 -5px 20px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .spiritual-footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.6), transparent);
        }

        .inspiration-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 30px;
            align-items: center;
        }

        .worship-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .worship-btn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 240, 120, 0.8));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 30px;
            padding: 15px 30px;
            color: #1a0f0f;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.4),
                0 3px 10px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .worship-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .worship-btn:hover::before {
            left: 100%;
        }

        .worship-btn:hover {
            background: linear-gradient(135deg, rgba(255, 240, 120, 1), rgba(255, 215, 0, 0.9));
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 10px 30px rgba(255, 215, 0, 0.5),
                0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 215, 0, 0.8);
        }

        .worship-btn.playing {
            background: linear-gradient(135deg, rgba(34, 139, 34, 0.8), rgba(50, 205, 50, 0.6));
            color: white;
            animation: pulse 2s infinite;
        }

        .worship-icon {
            font-size: 1.2em;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        .worship-text {
            font-size: 0.95em;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 16px rgba(34, 139, 34, 0.3); }
            50% { box-shadow: 0 8px 24px rgba(34, 139, 34, 0.6); }
        }

        .now-playing {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            font-size: 0.9em;
            color: #e8e8e8;
        }

        .audio-visualizer {
            display: flex;
            align-items: end;
            gap: 2px;
            height: 16px;
        }

        .audio-bar {
            width: 3px;
            background: linear-gradient(to top, #d4af37, #f4e976);
            border-radius: 2px;
            animation: audioViz 1.5s ease-in-out infinite;
        }

        .audio-bar:nth-child(1) { animation-delay: 0s; }
        .audio-bar:nth-child(2) { animation-delay: 0.3s; }
        .audio-bar:nth-child(3) { animation-delay: 0.6s; }
        .audio-bar:nth-child(4) { animation-delay: 0.9s; }

        @keyframes audioViz {
            0%, 100% { height: 4px; opacity: 0.5; }
            50% { height: 16px; opacity: 1; }
        }

        .scripture-motivation, .ministerial-wisdom {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }

        .scripture-text, .wisdom-text {
            font-style: italic;
            color: #e8e8e8;
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .scripture-reference, .wisdom-attribution {
            color: #d4af37;
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .inspiration-container {
                grid-template-columns: 1fr;
                gap: 20px;
                text-align: center;
            }
            
            .worship-btn {
                font-size: 0.9em;
                padding: 10px 20px;
            }
        }
    </style>

    <!-- Spiritual Inspiration Footer -->
    <footer class="spiritual-footer">
        <div class="inspiration-container">
            <div class="scripture-motivation" id="scriptureMotivation">
                <div class="scripture-text" id="scriptureText"></div>
                <div class="scripture-reference" id="scriptureReference"></div>
            </div>
            <div class="ministerial-wisdom" id="ministerialWisdom">
                <div class="wisdom-text" id="wisdomText"></div>
                <div class="wisdom-attribution" id="wisdomAttribution"></div>
            </div>
            <div class="worship-controls">
                <button id="worshipToggle" class="worship-btn" onclick="toggleWorship()">
                    <span class="worship-icon">🎵</span>
                    <span class="worship-text">Gentle Worship Sounds</span>
                </button>
                <div class="now-playing" id="nowPlaying" style="display: none;">
                    <div class="audio-visualizer">
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                    </div>
                    <span id="currentTrack"></span>
                </div>
            </div>
        </div>
    </footer>
</body>

</html>